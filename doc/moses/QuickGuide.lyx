#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble



\newtheorem{class}{class or struct}
\newtheorem{type}{type}


\title{MOSES --- A Quick Guide}
\author{Predrag Janicic}
\author{Revised, Linas Vepstas}
\end_preamble
\use_default_options false
\begin_modules
logicalmkup
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\ttfamily}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
MOSES - Quick Start
\end_layout

\begin_layout Author
Predrag Janicic, Revised by Linas Vepstas
\end_layout

\begin_layout Date
3 November 2008, revised 14 December 2011
\end_layout

\begin_layout Abstract
Meta-optimizing semantic evolutionary search (MOSES) is a new approach to
 program evolution, based on representation-building and probabilistic modeling.
 MOSES has been successfully applied to solve hard problems in domains such
 as computational biology, sentiment evaluation, and agent control.
 Results tend to be more accurate, and require less objective function evaluatio
ns, than other program evolution systems, such as genetic programming or
 evolutionary programming .
 Best of all, the result of running MOSES is not a large nested structure
 or numerical vector, but a compact and comprehensible program written in
 a simple Lisp-like mini-language.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Meta-optimizing semantic evolutionary search (MOSES) is a new approach to
 program evolution, based on representation-building and probabilistic modeling.
 MOSES has been successfully applied to solve hard problems in domains such
 as computational biology, sentiment evaluation, and agent control.
 Results tend to be more accurate, and require less objective function evaluatio
ns, in comparison to other program evolution systems.
 Best of all, the result of running MOSES is not a large nested structure
 or numerical vector, but a compact and comprehensible program written in
 a simple Lisp-like mini-language.
 For more information see 
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "http://metacog.org/doc.html"
target "http://metacog.org/doc.html"

\end_inset

.
\end_layout

\begin_layout Standard
The list of publications on MOSES is given in the References section.
 Moshe Look's PhD thesis 
\begin_inset CommandInset citation
LatexCommand cite
key "6"

\end_inset

 should be the first material to be read by someone interested in using
 or modifying MOSES.
\end_layout

\begin_layout Standard
MOSES is implemented in C++ and it heavily uses templates.
 So, one interested in modifying MOSES must be familiar with C++ and, at
 least to some extent, to C++ templates.
\end_layout

\begin_layout Section
Copyright Notice
\end_layout

\begin_layout Standard
MOSES is Copyright 2005-2008, Moshe Looks and Novamente LLC.
\end_layout

\begin_layout Standard
It is licensed under the Apache License, Version 2.0 (the "License"); you
 may not use this file except in compliance with the License.
 You may obtain a copy of the License at
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "http://www.apache.org/licenses/LICENSE-2.0"
target "http://www.apache.org/licenses/LICENSE-2.0"

\end_inset


\end_layout

\begin_layout Standard
Unless required by applicable law or agreed to in writing, software distributed
 under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
 OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and limitations
 under the License.
\end_layout

\begin_layout Section
Installation
\end_layout

\begin_layout Standard
To compile MOSES, you need
\end_layout

\begin_layout Itemize
a recent gcc (4.x or later); 
\end_layout

\begin_layout Itemize
the boost libraries (
\begin_inset CommandInset href
LatexCommand href
name "http://www.boost.org/"
target "http://www.boost.org/"

\end_inset

); 
\end_layout

\begin_layout Itemize
the CMake package (
\begin_inset CommandInset href
LatexCommand href
name "http://www.cmake.org/HTML/Index.html"
target "http://www.cmake.org/HTML/Index.html"

\end_inset

); 
\end_layout

\begin_layout Standard
For compiling MOSES, create a directory 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
build
\end_layout

\end_inset

 (from the root folder of the MOSES distribution), go under it and run 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

cmake ..
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

.
 This will create the needed build files.
 Then, make the project using 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

make
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 (again from the directory 
\family typewriter
build
\family default
).
 Generated executables will be in the folder 
\family typewriter
build/moses/learning/moses/main
\family default
.
 
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
MOSES performs supervised learning, and thus requires either a scoring function
 or training data to be specified as input.
 As output, it generates a Combo program that, when executed, approximates
 the scoring function.
 MOSES uses general concepts from evolutionary search, in that it maintains
 a population of programs, and then explores the neighborhood of modified,
 "mutated" programs, evaluating their fitness.
 After some number of iterations, the fittest program found is output.
\end_layout

\begin_layout Standard
More precisely, MOSES maintains a population of demes.
 Each deme is a program with many adjustable, tuneable parameters.
 These adjustable parameters are colloquially referred to as knobs.
 Thus, finding the fittest program requires not only selecting a deme, but
 also determining the best setting for the knobs.
\end_layout

\begin_layout Standard
The MOSES algorithm proceeds by selecting a deme and performing random mutations
 on it, by inserting new knobs in various random places.
 The best-possible knob settings for the mutated deme are found by using
 using existing, well-known optimization algorithms such as hill-climbing,
 simulated annealing or estimation of distribution algorithms (EDA) such
 as Bayesian optimization (BOA/hBOA).
 The fitness of the resulting program(s) can be compared to the fittest
 exemplar of other demes.
 If the new program is found to be more fit, it is used to start a new deme,
 (while discarding the old, dominated deme) and the process then repeats.
\end_layout

\begin_layout Standard
All program evolution algorithms tend to produce bloated, convoluted, redundant
 programs ("spaghetti code").
 To avoid this, MOSES performs reduction at each stage, to bring the program
 into normal form.
 The specific normalization used is based on Holman's "elegant normal form",
 which mixes alternate layers of linear and non-linear operators.
 The resulting form is far more compact than, say, for example, boolean
 disjunctive normal form.
 Normalization eliminates redundant terms, and tends to make the resulting
 code both more human-readable, and faster to execute.
\end_layout

\begin_layout Standard
The above two techniques, optimization and normalization, allow MOSES to
 out-perform standard genetic programming systems.
 The EDA algorithms, by finding the dependencies in a Bayesian network,
 in fact are able to find how different parts of a program are related.
 This quickly rules out pointless mutations that change one part of a program
 without making corresponding changes in other, related parts of the program.
 The other important ingredient, reduction to normal form, allows programs
 to become smaller, more compact, faster to execute, and more human readable.
 Besides avoiding spaghetti code, normalization removes redundancies in
 programs, thus allowing smaller populations of less complex programs, speeding
 convergence.
\end_layout

\begin_layout Standard
The programs that MOSES generates are "generic", in the sense that MOSES
 works with structured trees, represented in Combo.
 Such trees can represent propositional formula, procedural or functional
 programs, etc.
 The core MOSES solver is written in C++, and takes the form of a library.
 There are many example programs illustrating how to use this library.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Terminology
\end_layout

\begin_layout Standard
MOSES uses a vocabulary specific to itself.
 Some of the most important terms are defined below.
\end_layout

\begin_layout Description
Program.
 A 
\emph on
program
\emph default
, in MOSES, is represented as a tree of operators, variables and values.
 Nodes in the tree may be constants (bits, integers, real numbers, 
\emph on
etc.
\emph default
), boolean operators (
\emph on
and, or, etc.
\emph default
), arithmetical operators (+, -, *, 
\emph on
etc.
\emph default
), functions (
\emph on
sin, cos, etc.
\emph default
) or logical expressions (
\emph on
if...then...else, etc.
\emph default
), and so on.
 Arguments to an 
\emph on
n
\emph default
-ary function are denoted with hash marks, so that 
\begin_inset Formula $\#1,\#2,\ldots,\#n$
\end_inset

 would be the arguments.
 Thus, for example, 
\begin_inset Formula $(0<(0.5*\#1))\vee\#2$
\end_inset

 is a program that takes argument #1 (a float pt.
 number), multiplies it by 0.5, and checks to see if it is greater than zero.
 The result of this compare is or-ed (
\begin_inset Formula $\vee$
\end_inset

-ed) with argument #2 (a boolean).
 Although programs may be explicit, as in this example, a program can also
 be understood to be a 
\emph on
representation
\emph default
, together with a particular set of 
\emph on
knob settings
\emph default
, as explained below.
\end_layout

\begin_layout Description
Exemplar.
 An 
\emph on
examplar
\emph default
 is a specific program; typically, the fittest one found.
 
\end_layout

\begin_layout Description
Representation.
 A representation is a parameterized tree structure, representing a particular
 region of program space, centered around a single program (the 
\emph on
exemplar
\emph default
).
 A representation is derived from the examplar by inserting additional nodes
 in various (random) locations.
 The inserted nodes, however, are not specific values or functions or operators,
 but are rather place-holders for values/functions to be determined later.
 Each place-holder may be thought of as a 
\emph on
parameter
\emph default
, and is colloquially refered to as a 
\emph on
knob
\emph default
.
 Thus, a program is a representation, together with a particular setting
 of the knobs.
 During the optimization step in MOSES, the space of all possible parameter
 or knob settings will be explored, to locate the best possible settings,
 
\emph on
i.e
\emph default
.
 to find the fittest program.
 
\end_layout

\begin_layout Description
Knobs.
 A 
\emph on
knob
\emph default
 is a single dimension of variation relative to a representation tree.
 It may be discrete or continuous.
 For example, given the program tree fragment 
\begin_inset Formula $(0<(0.5*\#1))\vee\#2$
\end_inset

, a continuous knob might be used to vary the numerical constant 0.5 to other
 values.
 So, setting this knob to 
\begin_inset Formula $0.7$
\end_inset

 would transform this tree fragment to 
\begin_inset Formula $(0<(0.7*\#1))\vee\#2$
\end_inset

.
 A discrete knob with an arity of 1 might be used to transform the boolean
 input 
\begin_inset Formula $\#2$
\end_inset

, with 0 meaning 'always true', 1 meaning 'invert', 2 meaning 'don't invert'
 and 3 meaning 'always false'.
 So, setting this knob to 
\begin_inset Formula $1$
\end_inset

 would transform the above example tree to 
\begin_inset Formula $(0<(0.5*\#1))\vee(\neg\#2)$
\end_inset

.
 A discrete knob of arity 2 might be used to replace the less-than comparison
 with 
\begin_inset Formula $\leq,>,\geq,=$
\end_inset

or 
\begin_inset Formula $\ne$
\end_inset

, and so on.
 Another discrete knob of arity 2 might replace the '
\emph on
or
\emph default
' symbol 
\begin_inset Formula $\vee$
\end_inset

 with 
\begin_inset Formula $\wedge,\otimes$
\end_inset

, 
\emph on
etc.
 
\emph default
Knobs do not have to be defined as running over all possible values; it
 is usually convenient to keep knobs on a fairly restricted range.
\end_layout

\begin_layout Description
Representation-building.
 The step in the MOSES algorithm where an examplar is choosen, and a representat
ion is constructed from it.
 This representation is essentially the cornerstone of a deme.
\end_layout

\begin_layout Description
Deme.
 A 
\emph on
deme
\emph default
 is a population of programs derived from one single representation.
 Thus, a deme can be thought of as a population of knob settings.
 During the optimization phase, an optimizer algorithm, such as hill-climbing,
 simulated annealing, or the Bayesian optimization algorithm is used to
 work with the population, locating the best possible knob settings for
 the given representation.
 
\end_layout

\begin_layout Description
Metapopulation.
 MOSES maintains a collection of demes, playing each off the others.
 This set of demes is referred to as the 
\emph on
metapopulation
\emph default
.
 Pairs of demes are in competition; fitter demes are used to replace less
 fit demes.
\end_layout

\begin_layout Description
Scoring
\begin_inset space ~
\end_inset

function.
 During the optimization phase, candidate programs being explored are scored
 by a 
\emph on
scoring function
\emph default
.
 The function is specific to the given problem; it returns a value indicating
 how closely the candidate program matched the desired output.
 For supervised training problems, the scoring function just returns how
 closely the candidate program matched the training set.
 For demonstration problems, the scoring function is typically some well-studied
 toy problem, such as parity, santa-fe-trail, 
\emph on
etc.

\emph default
 Usually, the perfect score is 
\begin_inset Formula $0$
\end_inset

, while worse scores are negative.
 Fitter programs have higher scores.
\end_layout

\begin_layout Description
Domination.
 One deme is considered to 
\emph on
dominate
\emph default
 another if it is better in every way.
 During learning, demes typically do not dominate one-another: some are
 better at some parts of the scoring function, while others are better at
 other aspects.
 Thus, both are kept around and further evolved.
 Demes that are completely dominated are (usually) discarded.
\end_layout

\begin_layout Description
Normalization.
 The 
\emph on
normalization
\emph default
 step of the MOSES algorithm takes a program, and simplifies it, using 
\emph on
re-writing rules
\emph default
.
 The resulting program is said to be in 
\emph on
normal form
\emph default
.
 Thus, for example, 
\begin_inset Formula $\#3\vee F$
\end_inset

 can be reduced to just 
\begin_inset Formula $\#3$
\end_inset

 since or-ing with false changes nothing.
 Similarly, 
\begin_inset Formula $0<0.5*\#6$
\end_inset

 can be normalized to 
\begin_inset Formula $0<\#6$
\end_inset

 since multiplying by one-half never changes the sign of a number.
 Likewise, the expression 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mbox{if }(x=x)\mbox{ then }y$
\end_inset


\begin_inset Quotes erd
\end_inset

 can be reduced to 
\begin_inset Formula $y$
\end_inset

, since a value is always equal to itself, and so the if-branch is always
 taken.
 Normalization can sometimes eliminate large parts of a program, if they
 are vacuous or tautological.
 There are many different types of normalization that are possible; MOSES
 always normalizes to the so-called '
\emph on
elegant normal form
\emph default
'.
\end_layout

\begin_layout Section
MOSES Algorithm
\end_layout

\begin_layout Standard
The basic MOSES algorithm can be described as follows:
\end_layout

\begin_layout Enumerate
Choose one or more exemplars, expressed as program trees.
 Initially, this may be the empty program.
\end_layout

\begin_layout Enumerate
Representation-building step.
 For each exemplar, construct a representation; that is, a set of knobs
 based on the chosen exemplar.
 Generate a random sampling of knob values, i.e.
 of programs based on the representation.
 This is a deme; add this deme to the metapopulation, possibly displacing
 a less promising deme.
\end_layout

\begin_layout Enumerate
Select a deme from the metapopulation and iteratively update its sample,
 as follows:
\end_layout

\begin_deeper
\begin_layout Enumerate
Select some promising programs from the deme’s existing sample to use for
 modeling, according to the scoring function.
 Ties in the scoring function are broken by preferring smaller programs.
\end_layout

\begin_layout Enumerate
Considering the promising programs as collections of knob settings, generate
 new collections of knob settings by applying some (competent) optimization
 algorithm.
\end_layout

\begin_layout Enumerate
Convert the new collections of knob settings into their corresponding programs,
 evaluate their scores, and integrate them into the deme’s sample, replacing
 less promising programs.
 
\end_layout

\end_deeper
\begin_layout Enumerate
For each new program that meets the criteria for creating a new deme, go
 to step 2.
\end_layout

\begin_layout Standard
Note that representation-building, the optimization algorithm, and normalization
 are vital components of the system, and they crucially influence its performanc
e.
 Representation building is specific for each domain (e.g., learning propositional
 formulae), while the optimization algorithm is general.
 MOSES currently supports representation building for several problem domains,
 including propositional formulae, actions
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
By 
\begin_inset Quotes eld
\end_inset

actions
\begin_inset Quotes erd
\end_inset

 we mean mini programming languages describing actions of a agents such
 as artificial and 
\begin_inset CommandInset citation
LatexCommand cite
key "6"

\end_inset

.
 Available actions typically cover atomic instructions like 
\begin_inset Quotes eld
\end_inset

step forward
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

rotate left
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

rotate right
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

step forward
\begin_inset Quotes erd
\end_inset

, branching instruction such as ,,if-then-else
\begin_inset Quotes eld
\end_inset

, and loop instruction such as ,,while
\begin_inset Quotes eld
\end_inset

.
\end_layout

\end_inset

, and other things (XXX like what??).
 MOSES also supports several different optimization algorithms, including
 hill-climbing, simulated annealing and Bayesian optimization.
 Work on support-vector machine (SVM) optimization is underway.
 Only one form of program reduction, to elegant normal form, is supported.
 Other types of reduction, e.g.
 SAT-based or satisfiability-modulo-theory (SMT) may be possible but remains
 unexplored.
\end_layout

\begin_layout Standard
XXX todo: Above algorithm is not quite correct.
 In particular, the normalization step is omitted.
\end_layout

\begin_layout Section
Source Files and Folders
\end_layout

\begin_layout Standard
In the MOSES distribution, there are the following folders (under 
\family typewriter
moses/learning/moses
\family default
) with the source files:
\end_layout

\begin_layout Description
eda This folder contains support for estimation of distribution algorithms,
 and the lower level support for optimization algorithms.
 
\end_layout

\begin_layout Description
example-progs This folder contains examples demonstrating different features
 of the MOSES system: reducing expressions, and, of course, applications
 of MOSES itself.
 It includes examples for the "ant problem/santa-fe trail", for "parity
 formulae", 
\emph on
etc.
\end_layout

\begin_layout Description
main Contains the main moses executable.
\end_layout

\begin_layout Description
moses This folder contains the core support for MOSES -- including base
 type definitions, and distributed computation support.
 
\end_layout

\begin_layout Description
optimization Contains the main optimization code.
\end_layout

\begin_layout Description
representation Contains code for representation-building.
\end_layout

\begin_layout Section
Types, Structures, and Classes
\end_layout

\begin_layout Standard
This section briefly reviews some of the key datatypes and classes found
 in the code.
 
\end_layout

\begin_layout Subsection
Structured expression trees
\end_layout

\begin_layout Standard
For representing structured expression trees (programs, propositional formulae,
 
\emph on
etc
\emph default
.) MOSES relies on the library ComboReduct.
 In this library, structured expressions are represented by trees of the
 type
\emph on
 
\family typewriter
\emph default
combo tree 
\family default
as follows:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef Util::tree<vertex> combo_tree;
\end_layout

\end_inset

The file 
\family typewriter
comboreduct/combo/vertex.h 
\family default
defines 
\family typewriter
vertex 
\family default
as shown blow.
 It is done this way so that it can capture different sorts of nodes, for
 different, but still fixed, problem domains.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef boost::variant<builtin,
\end_layout

\begin_layout Plain Layout

		wildcard,
\end_layout

\begin_layout Plain Layout

		argument,
\end_layout

\begin_layout Plain Layout

		contint,
\end_layout

\begin_layout Plain Layout

		action,
\end_layout

\begin_layout Plain Layout

		builtinaction,
\end_layout

\begin_layout Plain Layout

		perception,
\end_layout

\begin_layout Plain Layout

		definiteobject,
\end_layout

\begin_layout Plain Layout

		indefiniteobject,
\end_layout

\begin_layout Plain Layout

		message,
\end_layout

\begin_layout Plain Layout

		procedurecall,
\end_layout

\begin_layout Plain Layout

		anntype,
\end_layout

\begin_layout Plain Layout

		actionsymbol> vertex; 
\end_layout

\end_inset

For more information, review the docs provided in the distribution of the
 ComboReduct library.
\end_layout

\begin_layout Subsection
Metapopulation
\end_layout

\begin_layout Standard
The metapopulation is a set of scored combo trees.
 Several types of scores are used, ranging from single floats, to composite
 scores that include a complexity measure, to 'behavioural' scores, consisting
 of vectors of floats.
 These are all defined in the file 
\family typewriter
learning/moses/moses/types.h.

\family default
 A 'scored combo tree' is then just a pair that associates a score with
 a tree:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef taggeditem<combo::combotree,
\end_layout

\begin_layout Plain Layout

		compositebehavioralscore> bscoredcombotree; 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The metapopulation is then a set of scored combo trees, defined in 
\family typewriter
learning/moses/moses/metapopulation.h.
 M
\family default
ore precisely, it is a class, inheriting from the set:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef std::set<bscoredcombotree> bscoredcombotreeset;
\end_layout

\begin_layout Plain Layout

struct metapopulation : public bscoredcombotreeset {...}; 
\end_layout

\end_inset

The metapopulation will store expressions (as scored trees) that were encountere
d during the learning process (not all of them; the weak ones, which are
 dominated by existing ones, are usually skipped as non-promising).
\end_layout

\begin_layout Standard
As an example, one can iterate through the metapopulation and print all
 its elements with their scores and complexities in the following way:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (constiterator it=begin(); it!=end(); ++it) 
\end_layout

\begin_layout Plain Layout

	cout << gettree(*it) << " " 
\end_layout

\begin_layout Plain Layout

		<< getscore(*it) << " "
\end_layout

\begin_layout Plain Layout

		<< getcomplexity(*it) << endl;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The metapopulation is updated in iterations.
 In each iteration, one of its elements is selected as an exemplar.
 The exemplar is then used for building a new deme (that will further extend
 the metapopulation).
\end_layout

\begin_layout Subsection
Deme
\end_layout

\begin_layout Standard
XXX some details below incorrect.
\end_layout

\begin_layout Standard
The metapopulation consists of expressions (stored as scored trees).
 These expressions do not refer to some exemplar.
 On the other hand, during the learning process, new demes are generated.
 A deme is centered around an exemplar from the metapopulation.
 However, elements of the deme are not represented as (scored) trees but,
 instead, are represented relative to the exemplar.
 So, the deme has the type (declared in 
\family typewriter
eda/instance_set.h
\family default
):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

eda::instanceset<treescore>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\family typewriter
instance_set
\family default
 is a set of scored instances, and 
\family typewriter
instance
\family default
 is declared in 
\family typewriter
eda/eda.h
\family default
 is a vector of packed knob settings:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef vector<packedt> instance;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The basic learning and optimization processes work over these instances,
 and not over trees.
 So, a suitable way for representing expressions/trees as sequences of bit/integ
er/real values (relative to the exemplar) enable abstract and clean optimization
 steps, uniform for different domains.
 This representation is based on representation building relative to a given
 exemplar.
\end_layout

\begin_layout Subsection
Representation
\end_layout

\begin_layout Standard
XXX some details below incorrect.
\end_layout

\begin_layout Standard
A structure describing a representation of a deme (relative to its exemplar)
 is declared in 
\family typewriter
moses/represetation.h
\family default
.
 Its constructor uses as arguments a simplification rule, an exemplar, a
 type tree, a pseudo-number generator and, optionally, just for actions
 (like for the ant problem), sets of available operators, perceptions, and
 actions).
\end_layout

\begin_layout Standard
The constructor of this structure, builds knobs with respect to the given
 exemplar (by the method 
\family typewriter
build_knobs
\family default
).
\end_layout

\begin_layout Standard
This structure stores the exemplar like a tree (more precisely 
\family typewriter
combo_tree
\family default
).
 This structure has a method for using a given instance to transform the
 exemplar (
\family typewriter
transform
\family default
) providing a new expression tree.
\end_layout

\begin_layout Standard
The structure also has methods for clearing the current version of the exemplar
 (setting all knobs to default values --- zeros) --- 
\family typewriter
clear_exemplar
\family default
, for getting the exemplar --- 
\family typewriter
get_clean_exemplar
\family default
, and for getting the reduced, simplified version of the exemplar 
\family typewriter
get_clean_exemplar
\family default
.
\end_layout

\begin_layout Section
Key Methods
\end_layout

\begin_layout Standard
This section briefly discusses key MOSES's methods.
\end_layout

\begin_layout Subsection
Representation Building
\end_layout

\begin_layout Standard
Representation building is one of the key aspects of the MOSES approach.
 It is implemented separately for different problem domains (propositional
 formulae, action, etc).
 Support for several problem domains is given in the file 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|moses/build_knobs.h/cc|
\end_layout

\end_inset

.
 Representation building starts with an exemplar and add to it new nodes
 and corresponding knobs (see 
\begin_inset CommandInset citation
LatexCommand cite
key "6"

\end_inset

).
 Knobs can have different settings.
 If all knobs are set to 0, then we the original exemplar is obtained.
\end_layout

\begin_layout Standard
There are several types of knobs, described in 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|moses/knobs.h|
\end_layout

\end_inset

.
 Some of them are suitable for propositional formulae (so some subexpression
 can be 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 present
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 absent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, or 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 negated
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

.
 In simple knobs, a subexpression can be just 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 present
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 absent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

.
 In action knobs, a node can have different settings, corresponding to atomic
 or compound actions, sampled as 
\begin_inset Quotes eld
\end_inset

perms
\begin_inset Quotes erd
\end_inset

 in the method 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|build_knobs::sample_action_perms|
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The key method is 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|void build_knobs::build_action(pre_it it)|
\end_layout

\end_inset

 --- it substantially determines the representation building for one domain
 and substantially influence the learning process.
\end_layout

\begin_layout Subsection
Optimization
\end_layout

\begin_layout Standard
The role of optimization is to score elements of the deme, and to process
 them and to generate new promising instances.
 The optimization process works over sequences of numbers (i.e., over 
\begin_inset Quotes eld
\end_inset

instances
\begin_inset Quotes erd
\end_inset

).
 It is invoked in the main procedure, in each iteration of expanding (the
 method 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|metapopulation::expand|
\end_layout

\end_inset

, implemented in the file 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|moses/moses.h|
\end_layout

\end_inset

) the metapopulation.
 The result is a set of instances that are transformed to trees and then
 added to the metapopulation (if they are not dominated by existing elements).
\end_layout

\begin_layout Standard
Currently, there are two optimization methods implemented (implemented in
 the file 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|moses/optimization.h|
\end_layout

\end_inset

): 
\end_layout

\begin_layout Description
univariate optimization based on Bayesian optimization (see 
\begin_inset CommandInset citation
LatexCommand cite
key "6"

\end_inset

);
\end_layout

\begin_layout Description
iterative hillclimbing based on a simple greedy iterative process, looking
 for a better than exemplar instance at distance 
\begin_inset Formula $1,2,3,\ldots$
\end_inset

; 
\end_layout

\begin_layout Standard
In addition, there is support for 
\begin_inset Quotes eld
\end_inset

sliced iterative hillclimbing
\begin_inset Quotes erd
\end_inset

, similar as the one as above, but using a time slicing, so it can be used
 in some wider context, without leaving other subtasks idle for too long.
\end_layout

\begin_layout Standard
Optimization algorithms also have to take care of number of evaluations
 (number of calls to scoring functions) used.
 Basically, this number controls the resources given to the algorithm.
\end_layout

\begin_layout Subsection
Scoring
\end_layout

\begin_layout Standard
While the representation building is specific for each problem domain, the
 scoring is specific for each specific problem.
 For instance, in learning propositional formulae, the same representation
 building algorithm is used, but different scoring functions will be used
 for each specific task (for instance, for learning disjunction or conjunction
 over the given set of propositional variables).
\end_layout

\begin_layout Standard
There is a 
\end_layout

\begin_layout Description
score function returning 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|int|
\end_layout

\end_inset

, generally with 0 as a perfect score, and negative numbers as worse scores;
 
\end_layout

\begin_layout Description
behavioral score function returning a vector of specific values, that is
 used for comparing expressions on different dimensions and for discarding
 elements dominated by other elements.
 
\end_layout

\begin_layout Standard
Technically, these functions are provided as operators within structures.
\end_layout

\begin_layout Standard
The scoring functions are used for instantiating higher-level functions
 used uniformly for different problem domains and different problems.
\end_layout

\begin_layout Standard
Some low-level, problem specific, scoring functions are defined in the file
 (under 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|src/MosesEda|
\end_layout

\end_inset

) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|moses/scoring_functions.h|
\end_layout

\end_inset

, while higher-level support is defined in the file 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|moses/scoring.h/cc|
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
MOSES: Putting It All Together
\end_layout

\begin_layout Standard
With all components briefly described above, this section discusses how
 are they combined in a system MOSES.
\end_layout

\begin_layout Standard
The main moses method is trivial: it only expand the metapopulation in iteration
s until the given number of evaluations or a perfect solution is reached.
 This method is implemented in 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|moses/moses.h|
\end_layout

\end_inset

, in several variations (some with additional arguments corresponding to
 available actions and perceptions, just for the action problem domain).
\end_layout

\begin_layout Standard
Typical usage of MOSES starts by providing scoring functions.
 For instance, for learning disjunction propositional formula one can use
 the following declaration (defined in 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|moses/scoring_functions.h|
\end_layout

\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\end_inset

 disjunction scorer; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
and for solving the ant problem, one can use the following declaration (defined
 in 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|moses/scoring_functions.h|
\end_layout

\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\end_inset

 antscore scorer; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Also, the type of expression to be learnt has to be provided 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
for a detail explanation of the type system used in ComboReduct see the
 doc provided with the distribution of ComboReduct
\end_layout

\end_inset

.
 For instance, for the disjunctive formula, one should use:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\end_inset

 typetree tt(id::lambdatype); tt.appendchildren(tt.begin(),id::booleantype,arity+1
); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|arity|
\end_layout

\end_inset

 carries the information of the number of propositional variables to be
 considered.
 For the ant problem, one would write:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\end_inset

 typetree tt(id::lambdatype); tt.appendchildren(tt.begin(),id::actionresulttype,1)
; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then the metapopulation has to be declared.
 It is instantiated via templates, saying which scoring function, which
 behavioral scoring function, and which optimization algorithm to use.
 As, arguments one has to provide the random generator, the initial exemplar,
 the type tree, simplification procedure, then the scorers and the optimization
 algorithm.
 This is an example for learning the disjunctive formula:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\end_inset

 metapopulation<logicalscore,logicalbscore,univariateoptimization> metapop(rng,
 vtree(id::logicaland),tt,logicalreduction(), logicalscore(scorer,arity,rng),
 logicalbscore(scorer,arity,rng), univariateoptimization(rng)); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
and this is an example for the ant problem:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\end_inset

 metapopulation<antscore,antbscore,univariateoptimization> metapop(rng,vtree(id:
:sequentialand),tt,actionreduction(), scorer, bscorer, univariateoptimization(rn
g)); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is also a version of MOSES that uses the sliced interactive hillclimbing
 --- 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|sliced_moses|
\end_layout

\end_inset

.
 It supports the action domain, but can be simply modify to support other
 domains as well.
\end_layout

\begin_layout Standard
These, and several more examples, can be found in the folder 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|main|
\end_layout

\end_inset

.
 The example programs provided often ask for arguments like the seed for
 the pseudo-random number generation or for the number of evaluations.
\end_layout

\begin_layout Section
Final Remarks
\end_layout

\begin_layout Standard
While MOSES is not that big a system, it cannot be documented in detail
 in just a few pages.
 However, the descriptions given above should be helpful when one first
 encounters MOSES and tries to use it and modify it.
\end_layout

\begin_layout Standard
Currently, MOSES together with ComboReduct consists of 17 KLOC of .cc files
 and 24 KLOC of header files, as counted by the wc command.
 This includes all comments, copyright notices, example programs and utilities.
 Of this, combo consists of about 18 KLOC while MOSES consists of 22 KLOC.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "1"

\end_inset

 Moshe Looks, "Scalable Estimation-of-Distribution Program Evolution", Genetic
 and Evolutionary Computation Conference (GECCO), 2007.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "2"

\end_inset

 Moshe Looks, "On the Behavioral Diversity of Random Programs", Genetic
 and Evolutionary Computation Conference (GECCO), 2007.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "3"

\end_inset

 Moshe Looks, "Meta-Optimizing Semantic Evolutionary Search", Genetic and
 Evolutionary Computation Conference (GECCO), 2007.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "4"

\end_inset

 Moshe Looks, Ben Goertzel, Lucio de Souza Coelho, Mauricio Mudado, and
 Cassio Pennachin,"Clustering Gene Expression Data via Mining Ensembles
 of Classification Rules Evolved Using MOSES", Genetic and Evolutionary
 Computation Conference (GECCO), 2007.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "5"

\end_inset

 Moshe Looks, Ben Goertzel, Lucio de Souza Coelho, Mauricio Mudado, and
 Cassio Pennachin, "Understanding Microarray Data through Applying Competent
 Program Evolution", Genetic and Evolutionary Computation Conference (GECCO),
 2007.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "6"

\end_inset

 Moshe Looks, "Competent Program Evolution" Doctoral Dissertation, Washington
 University in St.
 Louis, 2006.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "7"

\end_inset

 Moshe Looks, "Program Evolution for General Intelligence", Artificial General
 Intelligence Research Institute Workshop (AGIRI), 2006.
 
\end_layout

\end_body
\end_document
