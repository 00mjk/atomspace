#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{url} 
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "times" "default"
\font_sans "helvet" "default"
\font_typewriter "courier" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Connectors and Variables
\end_layout

\begin_layout Author
Linas Vepstas
\end_layout

\begin_layout Date
21 August 2020
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Revised version; Earlier version: 2 May 2020
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Almost all classical work on logic and symbolic reasoning, and indeed, much
 of mathematics, including lambda calculus and term algebras, are built
 on the intuitive foundation of 
\begin_inset Quotes eld
\end_inset

variables
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

functions
\begin_inset Quotes erd
\end_inset

 that map between them.
 Modern work on linguistics and category theory indicates an alternative
 viewpoint: that of 
\begin_inset Quotes eld
\end_inset

connectors
\begin_inset Quotes erd
\end_inset

.
 In this view, the act of replacing a variable by a value, and 
\begin_inset Quotes eld
\end_inset

plugging it into a function
\begin_inset Quotes erd
\end_inset

 (beta-reduction) is a special case of connecting a pair of connectors.
\end_layout

\begin_layout Abstract
This is a short note clarifying the relationship between these two concepts.
 Noteworthy is that the concept of connectors is 
\begin_inset Quotes eld
\end_inset

more general
\begin_inset Quotes erd
\end_inset

, and that, as a mathematical framework, it is far less explored.
\end_layout

\begin_layout Abstract
As a footnote, it is noted that the use of connectors (and the implied sheaf
 theory) appears to have impact on a number of philosophical arguments,
 ranging from mereology to postmodernism(!) This is a surprise.
 (The author acknowledges that it sounds perhaps cranky to place such claims
 in the abstract, but the notions are heart-felt.)
\end_layout

\begin_layout Section*
Introduction
\end_layout

\begin_layout Standard
In elementary mathematics, it is commonplace to speak of a variable, such
 as 
\begin_inset Formula $x$
\end_inset

, and functions of that variable, such as 
\begin_inset Formula $f(x)$
\end_inset

.
 The power of this abstraction is that variables can be assigned a value,
 and that value can be 
\begin_inset Quotes eld
\end_inset

plugged into
\begin_inset Quotes erd
\end_inset

 a function.
 For example, one asserts that 
\begin_inset Formula $x=42$
\end_inset

 and then ponders 
\begin_inset Formula $f(42)$
\end_inset

.
 This act of 
\begin_inset Quotes eld
\end_inset

plugging in
\begin_inset Quotes erd
\end_inset

 is formally called 
\begin_inset Quotes eld
\end_inset

beta reduction
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
This process of 
\begin_inset Quotes eld
\end_inset

plugging in
\begin_inset Quotes erd
\end_inset

 can be compared to the process of 
\begin_inset Quotes eld
\end_inset

connecting
\begin_inset Quotes erd
\end_inset

, for example, connecting together two jigsaw-puzzle pieces.
 When mating together connectors, one typically has a matched pair that
 can be mated: a plug that can be plugged into a socket.
 It should be clear that beta reduction is a special case of this: that
 
\begin_inset Formula $f(x)$
\end_inset

 is a 
\begin_inset Quotes eld
\end_inset

socket
\begin_inset Quotes erd
\end_inset

 into which values can be plugged into.
\end_layout

\begin_layout Standard
This observation seems nearly trivial; it is so painfully obvious that one
 wonders what more can be said.
 Yet there are tremendous consequences that arise from this, consequences
 that are in some sense equally trivial and obvious.
 That something is 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 is perhaps an indicator that it is important.
 This note dwells on these 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 ideas, and demonstrates their importance.
 The problem with 
\begin_inset Quotes eld
\end_inset

obviousness
\begin_inset Quotes erd
\end_inset

 is that it frames all manner of thinking: it is Aristotle's 
\begin_inset Quotes eld
\end_inset

formal cause
\begin_inset Quotes erd
\end_inset

, applied to thinking.
 It is provides a normative framework in which all conversation takes place.
 Design and thinking happen in the foreground; there is a 
\begin_inset Quotes eld
\end_inset

figure
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

ground
\begin_inset Quotes erd
\end_inset

, and anything that is obvious falls into the background, becomes implicit,
 and serves as a barrier to further thought and examination.
 Thus, the impetus for this note.
\end_layout

\begin_layout Standard
The starting point of this note is that, when one thinks of variables and
 functions, one is inevitably lead to the notion of 
\begin_inset Quotes eld
\end_inset

directed acyclic graphs
\begin_inset Quotes erd
\end_inset

 (DAGs).
 That is, plugging variables into functions, and those into other functions
 invariably leads to a DAG, because the sense of direction of 
\begin_inset Quotes eld
\end_inset

plugging in
\begin_inset Quotes erd
\end_inset

 must be preserved: one cannot plug a variable into a value; one cannot
 plug a function into a value; the plugging is always directed.
 One is a receptacle, the other is not.
 By contrast, that act of connecting together connectors has no such constraint:
 a jigsaw puzzle is not a DAG; there is no jigsaw piece 
\begin_inset Quotes eld
\end_inset

at the top
\begin_inset Quotes erd
\end_inset

, and none 
\begin_inset Quotes eld
\end_inset

at the bottom
\begin_inset Quotes erd
\end_inset

.
 Although the connectors in a jigsaw puzzle have a polarity, the sense of
 direction that they offer is immaterial to the final construction.
\end_layout

\begin_layout Standard
The desired conclusion is that by approaching knowledge representation as
 an assemblage of connections, rather than as a unidirectional network of
 inferences, one can gain considerable power in working with the common
 problems and stumbling blocks of AI and AGI, including problems of planning,
 inference, constraint satisfaction, combinatorial explosion and the 
\begin_inset Quotes eld
\end_inset

frame problem
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
This note begins with a long review of everywhere that the notion of variables
 and functions appear, or, more generally, of arrows and directed graphs.
 This may seem pointless, but serves only to underscore their ubiquity.
 This is followed by a section that develops the proposed alternative.
 Along the way, assorted commentary is made with regards to outstanding
 philosophical problems, as befits any exploration that belabors the 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section*
Arrows
\end_layout

\begin_layout Standard
Arrows, and usually accompanying DAGs are everywhere.
 They really are pervasive in descriptions of mathematics, in symbolic AI
 and knowledge representation, and even underpin vast tracts of philosophy.
 This is, again, so potently 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 that an explicit review is called for.
\end_layout

\begin_layout Subsubsection*
In philosophy:
\end_layout

\begin_layout Standard
Here's a hint of how pervasively important the concept of variables and
 values can be.
 Some philosophers use these notions to anchor the idea of 
\begin_inset Quotes eld
\end_inset

objects
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

things
\begin_inset Quotes erd
\end_inset

 that 
\begin_inset Quotes eld
\end_inset

exist
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

An object is anything that can be the value of a variable, that is, anything
 we can talk about using pronouns, that is, anything.
\begin_inset Quotes erd
\end_inset

 (Van Inwagen 2002, 180)
\end_layout

\begin_layout Standard
This conception of an object then leads to confused discussions about the
 identity of indiscernibles, and the importance of location (space-time)
 in mereology.
 The notion of connectors can be used as an alternate foundation for the
 conception of 
\begin_inset Quotes eld
\end_inset

objects
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

identity
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

location
\begin_inset Quotes erd
\end_inset

.
 Specifically, one can instead define objects as 
\begin_inset Quotes eld
\end_inset

things that can participate in relationships
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection*
In term algebra:
\end_layout

\begin_layout Standard
The theory of term algebras is a specific branch of mathematics that deals
 with the abstract process of performing generic algebraic manipulations,
 as any mathematician or engineer might do when working with pencil and
 paper.
 It is important for the theory of computation, because much what we do
 with computers is to manipulate symbols; term algebras provide a coherent
 vocabulary of ideas for thinking about algorithms that manipulate symbols.
 This is, in turn, important for both logic, and for symbolic AI, since
 reasoning engines and algorithmic theorem provers are built on such symbolic
 manipulations.
\end_layout

\begin_layout Standard
Consider a typical definition of a term algebra.
 It consists of:
\end_layout

\begin_layout Itemize
A set of constants 
\begin_inset Formula $c_{0},c_{1},\cdots$
\end_inset


\end_layout

\begin_layout Itemize
A set of variables 
\begin_inset Formula $x,y,z,\cdots$
\end_inset


\end_layout

\begin_layout Itemize
A set of 
\begin_inset Formula $n$
\end_inset

-ary function symbols 
\begin_inset Formula $f\left(x_{1},\cdots,x_{n}\right)$
\end_inset


\end_layout

\begin_layout Standard
The terms of a term algebra are then anything that can be constructed from
 the above, by recursively 
\begin_inset Quotes eld
\end_inset

plugging in
\begin_inset Quotes erd
\end_inset

.
 That the resulting terms always have the structure of a DAG should be intuitive
ly obvious.
\end_layout

\begin_layout Standard
In type theory, it is common to assign types to the different constants,
 variables and function symbols; this does not alter the result that the
 terms are DAGs.
\end_layout

\begin_layout Subsubsection*
In set theory:
\end_layout

\begin_layout Standard
In (well-founded) (naive) set theory, there is effectively just one function
 symbol: the set, and only one constant: the empty set.
 There are no variables, in the sense that proper sets do not contain variables
 in them.
 Of course, in the definition of the axioms (and axiom schemas!) that define
 set theory, and in the articulation of the theory itself, it is impossible
 to avoid variables; its just that variables are not set elements.
 By definition, 
\begin_inset Quotes eld
\end_inset

well-foundedness
\begin_inset Quotes erd
\end_inset

 disallows infinitely recursive sets.
 Thus, effectively, all finite sets in set theory have the shape of a DAG
 (they form a partial order).
\end_layout

\begin_layout Subsubsection*
In computer science:
\end_layout

\begin_layout Standard
Lambda calculus can be thought of as having arbitrary constants and variables,
 but only one function symbol: the lambda.
 It is effectively a theory of linear strings (sequences) of symbols arranged
 in order, on a line.
 Insofar as lambda expressions can be beta-reduced, they form a DAG.
 Lambda calculus is manifestly finite: it is very unusual to study countable
 or uncountable limits of lambda calculus.
 In general, lambda calculus is always assumed to be well-founded, so that
 the expressions are always DAGs.
 An exception to this is chem-lambda (Buliga 2003), which redefines lambda
 as having input and output connectors, thus allowing looping connections
 to be made.
\end_layout

\begin_layout Standard
The general typed lambda calculus famously corresponds to computer programs,
 this is the Curry-Howard correspondence.
 Infinite loops can be thought of in two ways in computing.
 One way is as a directed graph containing a loop: the arrows denote a function
 that recursively calls back to itself.
 The state transitions are described by points (for states) and arrows (denoting
 state transitions), arranged such that one (or more!) collections of arrows
 can be traced in a circular loop.
 The other way of thinking of infinite loops is as recursive structures:
 one unrolls the loop so that it becomes an infinitely-long unterminating
 sequence of arrows.
 Roughly speaking, infinite loops correspond to ill-founded sets.
 They are the 
\begin_inset Quotes eld
\end_inset

gunk
\begin_inset Quotes erd
\end_inset

 of philosophy.
\end_layout

\begin_layout Standard
The moral of the story that is being presented here is that almost all of
 computer science is founded on a theory of DAGs.
 Even when loops are allowed, the graphs are formed from edges that are
 directed: the edges are always arrows.
 This is not the same as a general theory of connectors connecting things
 together.
\end_layout

\begin_layout Subsubsection*
In topology:
\end_layout

\begin_layout Standard
The infinite binary tree provides a simple example of unrolling a pair of
 interconnected loops.
 Axiomatically, a binary tree is constructed from a pair of left-right elements,
 and each element can be another pair, or the termination symbol.
 In this sense, both the left and right elements can loop back onto themselves;
 when the loops are unrolled, the tree becomes infinite DAG (rather than
 a small graph containing a pair of loops).
 The endpoints of a binary tree form the Cantor set; there are an uncountable
 infinity of them.
 These are the 
\begin_inset Quotes eld
\end_inset

points
\begin_inset Quotes erd
\end_inset

 of point-set topology.
\end_layout

\begin_layout Standard
One can also have a point-free topology, built on top of lattice theory.
 Rather than considering points as mereological simples, one instead focuses
 on the directedness of set inclusion.
 Starting with the notion of a partially-ordered set, the axioms of lattice
 theory allow one to concentrate on meets and joins, filters and ideals,
 frames and locales, without once bringing up the notion of a point.
 Yet, in the end, partial orders are founded on the idea of direction, of
 inclusion, with set theoretic notions of the same providing much of the
 intuitive grounding.
 There is a DAG, even if discussion of terminal elements is avoided.
\end_layout

\begin_layout Subsubsection*
In category theory:
\end_layout

\begin_layout Standard
The simply typed lambda calculus is important, as it is the 
\begin_inset Quotes eld
\end_inset

internal language
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset Quotes eld
\end_inset

Cartesian closed categories
\begin_inset Quotes erd
\end_inset

.
 The Cartesian-closed categories naturally describe 
\begin_inset Quotes eld
\end_inset

tuples
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset Quotes eld
\end_inset

things
\begin_inset Quotes erd
\end_inset

: that is, things that can be placed in an ordered list (a 
\begin_inset Quotes eld
\end_inset

Cartesian product
\begin_inset Quotes erd
\end_inset

).
 The 
\begin_inset Quotes eld
\end_inset

things
\begin_inset Quotes erd
\end_inset

 are presumed to be discernible items
\begin_inset Foot
status open

\begin_layout Plain Layout
One could say 
\begin_inset Quotes eld
\end_inset

objects
\begin_inset Quotes erd
\end_inset

 instead of 
\begin_inset Quotes eld
\end_inset

items
\begin_inset Quotes erd
\end_inset

, as that is the appropriate term for category theory.
 It is, however, useful in the present case to use the slightly more vague
 term 
\begin_inset Quotes eld
\end_inset

items
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 that have an identity.
 Indiscernibles are not described by Cartesian closed categories; for this,
 needs symmetric monoidal categories.
 Tensors and tensor algebras, vector spaces and Hilbert spaces famously
 belong to this category; the internal language is 
\begin_inset Quotes eld
\end_inset

linear logic
\begin_inset Quotes erd
\end_inset

.
 Yet, the tensor category is dagger-compact: it has a left-right symmetry
 to it that constrains structure.
\end_layout

\begin_layout Standard
A pending critique of neural nets is that they are founded on vector spaces
 (and thus are part of the tensor category, which is symmetric) whereas
 natural language is described by monoidal categories that are manifestly
 not symmetric.
 This observation has been pursued elsewhere, in various writings by this
 author.
\end_layout

\begin_layout Standard
Category theory itself is a theory of dots and arrows.
 Every dot has an arrow back to itself (thus, a loop), and arrows can be
 composed: if there is a sequence of two arrows connecting three dots, then
 there always is an arrow, going in the same sense, between the two endpoints.
 This is all that a category is.
 Deep theorems follow, such as the existence of all limits, given only spans
 and equalizers! Category theory is surprising in it's power.
\end_layout

\begin_layout Standard
The moral of the story that is being presented here is that almost all of
 computer science is founded on a theory of DAGs.
 Even when loops are allowed, the graphs are formed from edges that are
 directed: the edges are always arrows.
 This is not the same as a general theory of connectors connecting things
 together.
\end_layout

\begin_layout Subsubsection*
In model theory:
\end_layout

\begin_layout Standard
Model theory takes the idea of a term algebra, and supplements it with relations.
 Relations are 
\begin_inset Formula $n$
\end_inset

-ary predicates 
\begin_inset Formula $P\left(t_{1},\cdots,t_{n}\right)$
\end_inset

 of terms 
\begin_inset Formula $t_{k}$
\end_inset

 from the term algebra.
 A predicate is either true, or it is false: it either holds or does not.
 The most famous predicate is that of equality; the 
\begin_inset Quotes eld
\end_inset

theory of pure equality
\begin_inset Quotes erd
\end_inset

 is a term algebra supplemented with a predicate defining equality.
\end_layout

\begin_layout Standard
Predicates are useless unless they can be combined using the operators of
 logic: 
\begin_inset Quotes eld
\end_inset

and
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

or
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

not
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

there exists
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

for all
\begin_inset Quotes erd
\end_inset

.
 Curiously enough, the rules for combining these operators again form a
 DAG: the sigma-pi hierarchy.
 Combining terms with predicates seems nearly enough to serve as a foundation
 for all mathematics.
 The sigma-pi hierarchy, taken on set theory, is extremely powerful.
 Just the first few levels: first-order logic and second-order logic are
 enough to meet the concerns of most classical mathematics.
 Even things that are 
\begin_inset Quotes eld
\end_inset

larger
\begin_inset Quotes erd
\end_inset

 than set theory can be represented in this hierarchy: this is the content
 of the Yoneda lemma.
\end_layout

\begin_layout Standard
The moral of the story is as before: when viewed from the meta-perspective,
 DAGs appear to be sufficient to describe all of mathematics.
 It is hardly a surprise that they are part of the ground, the background,
 and not a part of the figure.
 They are a part of the under-pinnings of the meta-mathematics, and are
 almost never overtly discussed.
\end_layout

\begin_layout Subsubsection*
In relational algebras:
\end_layout

\begin_layout Standard
Removing the term algebra but keeping the relations results in a 
\begin_inset Quotes eld
\end_inset

relational algebra
\begin_inset Quotes erd
\end_inset

, with examples of relations being 
\begin_inset Quotes eld
\end_inset

is-a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

has-a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

part-of
\begin_inset Quotes erd
\end_inset

.
 Limiting oneself to a single part-whole relationship, one arrives at mereology
 as a possible alternative to set theory as a foundation for mathematics.
 But one also arrives the the notion of 
\begin_inset Quotes eld
\end_inset

gunk
\begin_inset Quotes erd
\end_inset

 in philosophy (that, roughly speaking, infinite recursion is possible,
 when considering the structure of physical reality), as well as a number
 of puzzles dating to Ancient Greece (the Ship of Theseus: what happens
 when parts are replaced? The Statue and the Lump of Clay: what happens
 when parts are rearranged?).
 That there are such puzzles is perhaps endemic to the desire to apply part-whol
e relationships, and the adduced DAG partial orders as a fundamental ground
 on which to build philosophical discussions.
\end_layout

\begin_layout Subsubsection*
In knowledge representation:
\end_layout

\begin_layout Standard
A practical application of relational algebras can be found in the field
 of knowledge representation.
 Practical systems embodying relational algebras include key-value databases
 and SQL databases.
 The 
\begin_inset Quotes eld
\end_inset

key
\begin_inset Quotes erd
\end_inset

 is a named slot, the 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 is the item that is attached to the key (that occupies the 
\begin_inset Quotes eld
\end_inset

slot
\begin_inset Quotes erd
\end_inset

 named by the key).
 Hierarchical relations can be built by placing keys into slots: thus, for
 example, the Unix file-system is effectively a key-value database.
 On the surface, SQL databases seem to be quite different, having a tabular
 structure, consisting of a fixed schema (a fixed 
\begin_inset Formula $n$
\end_inset

-ary predicate), the instances of which are rows in a table.
 Yet it is famously the case that SQL and key-value databases are categorial
 opposites to one-another: if one takes the arrow relationships in one,
 and reverses the sense of the arrows, one obtains the other (Meyer 2011).
\end_layout

\begin_layout Standard
Actual data-sets occurring in knowledge representation include WordNet,
 which provides synonym, holonym and meronym relations.
 The urge to solve the 
\begin_inset Quotes eld
\end_inset

grounding problem
\begin_inset Quotes erd
\end_inset

 leads to 
\begin_inset Quotes eld
\end_inset

upper ontologies
\begin_inset Quotes erd
\end_inset

, such as SUMO, which asserts that things are objects, and classifies types
 of things.
 Ontologies themselves force the user to make distinctions between intensional
 and extensional membership, intensional and extensional inheritance.
 For example, one can assert that dogs are a kind of animal (intensional)
 and then assert that 
\begin_inset Quotes eld
\end_inset

Fluffy
\begin_inset Quotes erd
\end_inset

 is an example of a dog (extensional - belongs to the class of dogs).
\end_layout

\begin_layout Standard
Ontologies provide only a handful of such relationships (is-a, has-a, part-of).
 To generalize to a greater number of relations, one arrives at the notion
 of 
\begin_inset Quotes eld
\end_inset

semantic triples
\begin_inset Quotes erd
\end_inset

: these are effectively labeled arrows: the two endpoints (head and tail)
 of the arrow, and a label for the relationship type.
\end_layout

\begin_layout Standard
As before, the presence of arrows implies ordering relationships, with concomita
nt notions of transitivity, (anti-)reflexivity, (anti-)symmetry, even when
 they may be a good bit more fuzzy and vague, as in the domain of 
\begin_inset Quotes eld
\end_inset

common sense
\begin_inset Quotes erd
\end_inset

.
 As Spock might say, human gut feels are not logical.
\end_layout

\begin_layout Section*
Graphs
\end_layout

\begin_layout Standard
Unlike the examples above, graph theory offers a different possibility:
 the undirected edge.
 Unfortunately, this is again 
\begin_inset Quotes eld
\end_inset

painfully obvious
\begin_inset Quotes erd
\end_inset

, and we'll have to slog through a lot of rather obvious observations to
 make anything resembling progress.
\end_layout

\begin_layout Standard
The canonical definition of a graph is that of two sets: a set 
\begin_inset Formula $V$
\end_inset

 of vertices and a set 
\begin_inset Formula $E$
\end_inset

 of edges.
 An edge 
\begin_inset Formula $e_{k}\in E$
\end_inset

 is a pair 
\begin_inset Formula $e_{k}=\left\{ v_{i},v_{j}\right\} $
\end_inset

 of vertices, with each 
\begin_inset Formula $v_{i}\in V$
\end_inset

.
 Although this definition is adequate for most mathematical applications,
 it is severely deficient for algorithmic applications.
 The biggest issue is that of non-locality of data.
 If one merely stuffs the vertices and edges into a table, then a graph
 walk in general appears to look like a uniformly distributed random hop
 through those tables: terrible for modern computers which rely on locality,
 so that caches can speed data access performance.
\end_layout

\begin_layout Standard
This section develops an alternative representation for graphs, and argues
 that it is foundational in nature.
 It addresses not only some of the practical problems in the DAG-view of
 the world (of the noosphere) but also provides an alternative to some of
 the philosophical foundations of the same.
\end_layout

\begin_layout Subsubsection*
Seeds
\end_layout

\begin_layout Standard
The problem of locality can be (partly) solved by defining graphs in a different
 way: in terms of vertexes, and the (half-)edges that attach to each vertex.
 In this case, one creates a table of pairs 
\begin_inset Formula $\left(v_{i},\left\{ e_{i1},e_{i2},\cdots,e_{ik}\right\} \right)$
\end_inset

 of a vertex 
\begin_inset Formula $v_{i}$
\end_inset

 and the set of all edges landing on that vertex.
 It is convenient to think of the edges as 
\begin_inset Quotes eld
\end_inset

half-edges
\begin_inset Quotes erd
\end_inset

, as it is enough to identify the remote end to which they connect; the
 local end is implicit: it is just the vertex 
\begin_inset Formula $v_{i}$
\end_inset

 at the 
\begin_inset Quotes eld
\end_inset

center
\begin_inset Quotes erd
\end_inset

.
 As this is obvious, it can be belabored with a diagram.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/seed.eps
	lyxscale 60
	width 25col%

\end_inset


\end_layout

\begin_layout Standard
The black dot represents the vertex; the open circles represent the unconnected
 half-edges.
 As this vaguely resembles a burr, this general shape will be referred to
 as a 
\begin_inset Quotes eld
\end_inset

seed
\begin_inset Quotes erd
\end_inset

, or sometimes a 
\begin_inset Quotes eld
\end_inset

germ
\begin_inset Quotes erd
\end_inset

 in what follows.
 Connecting these proceeds in the 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 fashion, and so a pair of connected seeds is shown below:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/seeds-two.eps
	lyxscale 60
	width 30col%

\end_inset


\end_layout

\begin_layout Standard
The unconnected dots, the half-edges, can be called connectors, in which
 the jigsaw-puzzle piece analogy comes into full force.
 Another 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 diagram illustrates this:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/puzzle.eps
	lyxscale 60
	width 45col%

\end_inset


\end_layout

\begin_layout Standard
The explicit polarity of the mating, despite the fact that the resulting
 edge is an undirected edge, serves several purposes.
 Foremost, it helps avoid mating errors: if the connectors do not have opposite
 polarity, they cannot attach.
 Secondly, they can be used to establish directionality, when that is needed.
 As the previous section noted, directed edges are everywhere; this did
 not mean to imply that they are useless! The collection of tabs and sockets
 can come in a large variety of shapes.
 These shapes correspond to the 
\begin_inset Quotes eld
\end_inset

types
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset Quotes eld
\end_inset

type theory
\begin_inset Quotes erd
\end_inset

.
 Most importantly, the concept of vertices adorned with connectors allows
 one to define a concept of a grammar.
\end_layout

\begin_layout Subsubsection*
Sections and Compostionality
\end_layout

\begin_layout Standard
The burrs/seeds/puzzle-pieces, as presented above, are obviously 
\begin_inset Quotes eld
\end_inset

compositional
\begin_inset Quotes erd
\end_inset

, in that there is an obvious way to connect them together.
 Once connected, the resulting structure is again of the same form: some
 network of vertices connected with edges, and some unconnected half-edges
 sticking out of it.
 Furthermore, it should be clear that the order in which pieces are assembled
 is immaterial: one obtains the same figure, no matter what the sequence.
\end_layout

\begin_layout Subsubsection*
In philosophy:
\end_layout

\begin_layout Standard
The paradoxes of mereology were touched on in the previous section: the
 difficulty of defining part-whole relationships in a consistent manner,
 the problem of the existence or non-existence of 
\begin_inset Quotes eld
\end_inset

gunk
\begin_inset Quotes erd
\end_inset

, and even the puzzles from Ancient Greece (the Ship of Theseus, 
\emph on
etc
\emph default
.) One proposed solution to these riddles is the notion of 
\begin_inset Quotes eld
\end_inset

restricted composition
\begin_inset Quotes erd
\end_inset

 (see Wikipedia).
 The idea is that 
\begin_inset Quotes eld
\end_inset

things
\begin_inset Quotes erd
\end_inset

 are still composed of 
\begin_inset Quotes eld
\end_inset

other things
\begin_inset Quotes erd
\end_inset

, but the manner in which these can be composed is restricted.
 The body of ideas is very nearly identical to the concept of sheaves.
 Quoting directly from the Wikipedia article on mereology, we can can learn
 that these are:
\end_layout

\begin_layout Itemize
Contact—that a complex object Y is composed of X's if and only if the X's
 are in contact.
 
\emph on
viz.
 
\emph default
seeds attach only if they can be connected.
\end_layout

\begin_layout Itemize
Fastenation—the X's compose a complex Y if and only if the X's are fastened.
 
\emph on
viz.

\emph default
 seeds attach only if the connectors allow mating.
 Once mated, they are fastened together.
\end_layout

\begin_layout Itemize
Cohesion—the X's compose a complex Y if and only if the X's cohere (cannot
 be pulled apart or moved in relation to each other without breaking).
 The point of connectors is that they are not meant to be pulled apart,
 once mated.
 Insofar as the above abstract definition of a sheaf failed to appeal to
 and forced order of the connectors, or to the length of the edges, the
 concept of 
\begin_inset Quotes eld
\end_inset

movement
\begin_inset Quotes erd
\end_inset

 remains incomplete
\begin_inset Foot
status open

\begin_layout Plain Layout
This can be repaired in a variety of ways.
 In practical applications, it is convenient to order the edges, and to
 give them weights.
 These weights can sometimes act as distances, e.g.
 in 
\begin_inset Formula $N$
\end_inset

-dimensional space.
 Furthermore, the branch of mathematics known as 
\begin_inset Quotes eld
\end_inset

algebraic topology
\begin_inset Quotes erd
\end_inset

 is very highly developed, and can provide very explicit and concrete statements
 about the structure of space.
 For example, the dimensionality of the embedding of the network is given
 by the degree of the largest simplicial complex in the network.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Fusion—the X's compose a complex Y if and only if the X's are fused (fusion
 is when the X's are joined together such that there is no boundary).
 Connectors, once connected, serve no further purpose, and are discarded.
 What mattered was the bond that was made.
 In this sense, the bonds are the fusion of connectors.
\begin_inset Foot
status open

\begin_layout Plain Layout
This is reminiscent of Derridas statement that 
\begin_inset Quotes eld
\end_inset

deconstruction is not analysis
\begin_inset Quotes erd
\end_inset

.
 One cannot break up meaning into atomic parts; there are no self-sufficient
 atomic parts of meaning.
 Meaning derives only from the fusion of words into text and into language.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Brutal Composition—"It's just the way things are." There is no true, nontrivial,
 and finitely long answer.
\end_layout

\begin_layout Standard
The last point is perhaps the most interesting notion coming out of restricted
 composition.
 It is not an ingredient, it is rather a consequence.
 If one abandons the explicit DAGs of partial orders, one then also abandons
 the notion of logical predicates and truth assignments.
 One no longer arranges logical connectives into a tree structure, or even
 into Horn clauses.
 The network, rather, represents things 
\begin_inset Quotes eld
\end_inset

as they are
\begin_inset Quotes erd
\end_inset

.
 This is not to deny predicate logic, or Boolean satisfiability: these are
 tremendously useful concepts.
 Rather, this is to avoid the symbol grounding problem (ref Wikipedia, again).
 By discarding the arrow from 
\begin_inset Quotes eld
\end_inset

signifier
\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Quotes eld
\end_inset

significand
\begin_inset Quotes erd
\end_inset

, one can no longer peer into the gaping chasm of the question 
\begin_inset Quotes eld
\end_inset

what does this symbol mean?
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
This is very much in line with theories of postmodernism and deconstruction
 evident in the works of Derrida,
\begin_inset Foot
status open

\begin_layout Plain Layout
The différance of Derrida can be seen as a rejection of the linguistic equivalen
t of mereological nihilism: there is no infinite regression of looking up
 the meanings of words in a dictionary.
\end_layout

\end_inset

 Deleuze, Lyotard.
 There is no difference between appearance and true form; the difference
 is undecidable.
 The constructed network of connections and relations is all there is.
\end_layout

\begin_layout Standard
In the following sections, the sheaf construction will be used as a tool
 to create A(G)I representations of reality.
 Whether the constructed network is an accurate representation of reality
 is undecidable, and this is true even in a narrow formal sense.
 Famously, it is known that the question of whether two different presentations
 of a (group-theoretical) group refer to the same group is undecidable,
 in the computational sense: there is no algorithm, guaranteed to terminate
 in finite time, that is capable of making this decision.
 This is the undecidability problem in group theory.
 That this result carries over into the fullness of a network built from
 a sheaf should come as no surprise: the presentation of a group is little
 more than a certain collection of labeled vertexes and edges (the group
 elements and the group operations) and decidability requires the graph-rewritin
g of these into a different form.
 There are no graph rewrite rules that can always bring two different presentati
ons into normal form.
 Oddly enough, such 
\begin_inset Quotes eld
\end_inset

received wisdom
\begin_inset Quotes erd
\end_inset

 from mathematics can be used as a foundational cornerstone for post-modernism.
 This is unexpected.
\begin_inset Foot
status open

\begin_layout Plain Layout
Despite this, sheaves are still somehow fundamentally 
\begin_inset Quotes eld
\end_inset

structuralist
\begin_inset Quotes erd
\end_inset

, not post-structuralist.
 The bonds are relational, in the end.
 There is always still a predicate: either an edge exists, or it doesn't.
 To every graph there is a corresponding adjacency matrix, populated with
 zeroes and ones.
 Fortunately, one can wriggle ones way out if this, by assigning numerical
 weights to edges, making some probable and some improbable.
 Whether true and false can be replaced by a subobject classifier in this
 context is perhaps a step too far, but perhaps also an interesting step.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A more explicit bridge can be constructed via linguistics, in the following.
\end_layout

\begin_layout Section*
Tensors
\end_layout

\begin_layout Standard
Much of what has been said above can be made slightly more precise with
 the aid of mathematical notation.
 This section reviews the concept of a tensor, starting from its most narrow
 form, and broadening it to a general setting.
 It is hoped that the reader already knows what a tensor is, as otherwise,
 most of this may seem pointless.
 The explanation begins very simply, at the freshman level; do not be mislead
 by the simplicity, there are a few tricks in here.
\end_layout

\begin_layout Standard
Four properties of tensors will be exposed and articulated.
 These may seem strange and idiosyncratic, if you already know what a tensor
 is; but communicating the strangeness is why we write.
\end_layout

\begin_layout Itemize
A means of storing data in a particular form or shape.
\end_layout

\begin_layout Itemize
The tensor product as a kind of concatenation and 
\begin_inset Quotes eld
\end_inset

forgetting
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
The inner product as a kind of 
\begin_inset Quotes eld
\end_inset

plugging together of connectors
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Types and fibers.
\end_layout

\begin_layout Standard
These properties can be taken in contrast to conventional expositions, which
 emphasizes multi-linearity and and behavior under change-of-basis.
 The change in focus is required to build the abstract notion of a tensor.
\end_layout

\begin_layout Subsection*
Tensors as databases
\end_layout

\begin_layout Standard
The conventional definition of a tensor in science and engineering starts
 with the introduction of the concept of a scalar 
\begin_inset Formula $s$
\end_inset

: a single number usually taken to be a real number or a complex number
 or even, abstractly, taken from some ring 
\begin_inset Formula $R$
\end_inset

.
 A vector 
\begin_inset Formula $v=\left[v_{1},v_{2},\cdots,v_{n}\right]$
\end_inset

 is a sequence of numbers.
 A matrix 
\begin_inset Formula $M=\left[M\right]=M_{ij}=M(i,j)$
\end_inset

 is a square of numbers, indexed by rows and columns 
\begin_inset Formula $i,j$
\end_inset

.
 The equality signs here just suggest different ways (different notations)
 of writing the same thing.
 A 3-tensor 
\begin_inset Formula $T_{ijk}=T(i,j,k)$
\end_inset

 is a cube of numbers; a 4-tensor 
\begin_inset Formula $T_{ijkm}=T(i,j,k,m)$
\end_inset

 is a 4-dimensional 
\begin_inset Quotes eld
\end_inset

hypercube
\begin_inset Quotes erd
\end_inset

 of numbers, and so on.
\end_layout

\begin_layout Standard
That tensors can be used to 
\begin_inset Quotes eld
\end_inset

store data
\begin_inset Quotes erd
\end_inset

 sounds a bit silly, or perhaps painfully obvious, given the conventional
 definition.
 None-the-less, tensors are a form of 
\begin_inset Quotes eld
\end_inset

database
\begin_inset Quotes erd
\end_inset

, where 
\begin_inset Quotes eld
\end_inset

data
\begin_inset Quotes erd
\end_inset

 (the number) has been 
\begin_inset Quotes eld
\end_inset

stored
\begin_inset Quotes erd
\end_inset

 at a 
\begin_inset Quotes eld
\end_inset

location
\begin_inset Quotes erd
\end_inset

 determined by the indexes (which are taken as ordinal numbers).
 This becomes a slightly more interesting observation when one realizes
 that computer-science has a small armada of similar devices for storing
 data: arrays and vectors and lists and lookup tables and the like.
 In comp-sci, considerations such as speed, space, accessibility, mutability
 become important, and strongly affect algorithms.
 That a tensor has the form of a database becomes even more interesting
 when one ponders how to store extremely sparse tensors: those whose entries
 are mostly zero, with a scattering of non-zero entries.
 Consider a matrix with one million rows and one million columns: this has
 
\begin_inset Formula $10^{6}\times10^{6}=10^{12}$
\end_inset

 locations; were we to splat a 64-bit floating-point number down at each
 location, this would require 
\begin_inset Formula $8\times10^{12}$
\end_inset

 bytes of storage: 8 terabytes.
 If all of those locations were zero, except for possibly for 
\begin_inset Formula $10^{6}$
\end_inset

 here or there ...
 that would be an insane waste of RAM: storing a million non-zero numbers
 requires only 8 megabytes, not 8 terabytes.
\end_layout

\begin_layout Standard
For sparse tensors, the preferred storage mechanism takes the form of a
 
\begin_inset Quotes eld
\end_inset

seed
\begin_inset Quotes erd
\end_inset

, already illustrated in a figure above.
 Lets repeat it:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/seed-unlabelled.eps
	lyxscale 60
	width 25col%

\end_inset


\end_layout

\begin_layout Standard
The black dot at the center is the 
\begin_inset Quotes eld
\end_inset

data
\begin_inset Quotes erd
\end_inset

 (the number).
 The white dots are the 
\begin_inset Quotes eld
\end_inset

tensor indexes
\begin_inset Quotes erd
\end_inset

 – the ordinal-number valued tuple identifying the location of the data.
 The figure shows five connectors, and thus an entry in a 5-tensor.
\end_layout

\begin_layout Subsection*
Tensor products
\end_layout

\begin_layout Standard
We begin with the conventional definition of the tensor product, before
 generalizing it in a later section.
\end_layout

\begin_layout Standard
The tensor product is conventionally denoted with the 
\begin_inset Quotes eld
\end_inset

otimes
\begin_inset Quotes erd
\end_inset

 symbol 
\begin_inset Formula $\otimes$
\end_inset

.
 This intimidating symbol is used to emphasize the multi-linearity of the
 tensor product.
 That is, if 
\begin_inset Formula $u,v$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

 are vectors, and 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 are constant numbers, then 
\begin_inset Formula 
\[
\left(au+bv\right)\otimes w=au\otimes w+bv\otimes w
\]

\end_inset

for the left side of the product, and likewise for the right: that this
 works on both sides is what makes it multi-linear.
 The 
\begin_inset Formula $\otimes$
\end_inset

 symbol is required because the Cartesian product symbol 
\begin_inset Formula $\times$
\end_inset

 does not work, it is not multi-linear.
 Consider, for example, the two ordered pairs 
\begin_inset Formula $u\times w=\left(u,w\right)$
\end_inset

 and 
\begin_inset Formula $v\times w=\left(v,w\right)$
\end_inset

.
 How can we multiply a scalar times an ordered pair? Conventionally, one
 re-scales all of the components.
 That is, 
\begin_inset Formula $a.\left(u,w\right)=\left(a.u,a.w\right)$
\end_inset

 but this fails spectacularly in terms of multi-linearity:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
a.\left(u,w\right)+b.\left(v,w\right)=\left(a.u,a.w\right)+\left(b.v,b.w\right)=\left(au+bv,aw+bw\right)\ne\left(au+bv,w\right)
\]

\end_inset

The tensor product 
\begin_inset Formula $\otimes$
\end_inset

 is not the Cartesian product 
\begin_inset Formula $\times$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Tensor products as equivalence
\end_layout

\begin_layout Standard
The tensor product can be constructed from the Cartesian product by declaring
 an equivalence.
 From the multi-linearity property above, it's clear that we wish to say
 that 
\begin_inset Formula $au\times w$
\end_inset

 is the same thing as 
\begin_inset Formula $u\times aw$
\end_inset

.
 That is, we already have defined the tensor product so that 
\begin_inset Formula $au\otimes w=u\otimes aw$
\end_inset

 as strict equality; yet this is patently false for ordinary ordered pairs.
\end_layout

\begin_layout Standard
The procedure to rectify this situation is to introduce a new notion of
 equivalence.
 Using the symbol 
\begin_inset Formula $\sim$
\end_inset

 to denote 
\begin_inset Quotes eld
\end_inset

the same as
\begin_inset Quotes erd
\end_inset

, one writes 
\begin_inset Formula $au\times w\sim u\times aw$
\end_inset

.
 The usual laws of algebra should apply, so subtraction can be used to bring
 everything over to one side: 
\begin_inset Formula $au\times w-u\times aw\sim0$
\end_inset

.
 That is, the difference of these two ordered pairs is the 
\begin_inset Quotes eld
\end_inset

same as
\begin_inset Quotes erd
\end_inset

 zero.
 Switching notation for ordered pairs, one may write 
\begin_inset Formula $\left(au,w\right)-\left(u,aw\right)\sim0$
\end_inset

.
 The algebra is meant to behave 
\begin_inset Quotes eld
\end_inset

as expected
\begin_inset Quotes erd
\end_inset

, and so
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left(au,w\right)-\left(u,aw\right)=\left(au-u,w-aw\right)=\left(\left(a-1\right)u,\left(1-a\right)w\right)\sim0
\]

\end_inset

But 
\begin_inset Formula $a-1$
\end_inset

 is just a number 
\begin_inset Formula $c=a-1$
\end_inset

, so the above says 
\begin_inset Formula 
\[
\left(cu,-cw\right)\sim0
\]

\end_inset

for all numbers 
\begin_inset Formula $c$
\end_inset

.
 Such ordered pairs are 
\begin_inset Quotes eld
\end_inset

equivalent
\begin_inset Quotes erd
\end_inset

 to zero.
\end_layout

\begin_layout Standard
The formal way to write the tensor product is as a quotient over this equivalenc
e.
 This is conventionally written as 
\begin_inset Formula 
\[
U\otimes W=U\times W/\sim
\]

\end_inset

which is meant to denote the set of all equivalent ordered pairs.
 In set notation,
\begin_inset Formula 
\[
u\otimes w=\left\{ \mbox{all pairs }\left(s,t\right)\mbox{ such that }\left(s,t\right)=\left(u,w\right)+\left(cu,-cw\right)\mbox{ for some const }c\right\} 
\]

\end_inset

This is to be read 
\begin_inset Quotes eld
\end_inset

the set of all pairs to which we have added the equivalent of zero
\begin_inset Quotes erd
\end_inset

.
 Formally, the set on the right is called 
\begin_inset Quotes eld
\end_inset

coset
\begin_inset Quotes erd
\end_inset

.
 By treating all members of this coset as 
\begin_inset Quotes eld
\end_inset

equivalent
\begin_inset Quotes erd
\end_inset

, we 
\begin_inset Quotes eld
\end_inset

forget
\begin_inset Quotes erd
\end_inset

 their identity and uniqueness (stemming from their origins as Cartesian
 pairs), and treat them as being all the same.
 Choosing any one exemplar from the coset will do; it is a form of 
\begin_inset Quotes eld
\end_inset

forgetting
\begin_inset Quotes erd
\end_inset

 of differences, or an 
\begin_inset Quotes eld
\end_inset

erasure
\begin_inset Quotes erd
\end_inset

 of origins.
 It is a denial of identity politics, it is a certain racial homogenization,
 it is a democratic notion that 
\begin_inset Quotes eld
\end_inset

all are created equal
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Tensor products as concatenation
\end_layout

\begin_layout Standard
The above was needlessly complicated.
 There is a wildly simpler way of saying the same thing, which, remarkably,
 arrives at the same place.
 Let 
\begin_inset Formula $F\left(x,y,z\right)$
\end_inset

 be a function of variables 
\begin_inset Formula $x,y,z$
\end_inset

 which are understood to be ordinal numbers, that is, integers.
 Without any further restrictions (for the moment, as we ignore change-of-basis,
 for now), the function 
\begin_inset Formula $F\left(x,y,z\right)$
\end_inset

 is a tensor, and the 
\begin_inset Formula $x,y,z$
\end_inset

 are the tensor indexes.
 Given another function aka tensor 
\begin_inset Formula $G\left(s,t\right)$
\end_inset

, the tensor product is simple the tensor 
\begin_inset Formula 
\[
T\left(x,y,z,s,t\right)=F\left(x,y,z\right)G\left(s,t\right)
\]

\end_inset

where the product is simply the scalar product.
 This seems almost trivial in it's definition – how hard can a scalar product
 be? Its just the ordinary multiplication of numbers.
 This seems effectively trivial, but it hides a bit of trickery: there's
 a sleight-of-hand.
 The tensor on the left-hand side is written as 
\begin_inset Formula $T\left(x,y,z,s,t\right)$
\end_inset

 and not as 
\begin_inset Formula $T\left(\left(x,y,z\right),\left(s,t\right)\right)$
\end_inset

.
 If we look at 
\begin_inset Formula $\left(x,y,z\right)$
\end_inset

 and 
\begin_inset Formula $\left(s,t\right)$
\end_inset

 as two ordered lists, then 
\begin_inset Formula $\left(x,y,z,s,t\right)$
\end_inset

 is the concatenation of those lists.
 It is NOT the Cartesian product of them!
\end_layout

\begin_layout Standard
As always, let's belabor the painfully obvious:
\begin_inset Formula 
\[
\left(x,y,z,s,t\right)\ne\left(x,y,z\right)\times\left(s,t\right)=\left(\left(x,y,z\right),\left(s,t\right)\right)
\]

\end_inset

The right side is a list.
 The left side is a list of lists.
 List concatenation 
\begin_inset Quotes eld
\end_inset

erases
\begin_inset Quotes erd
\end_inset

 the nested parenthesis that appear on the right-hand-side.
 It 
\begin_inset Quotes eld
\end_inset

forgets
\begin_inset Quotes erd
\end_inset

 where the indexes came from.
 Indeed, it might have been the case that the list was the result of concatenati
ng 
\begin_inset Formula $\left(x,y\right)$
\end_inset

 with 
\begin_inset Formula $\left(z,s,t\right)$
\end_inset

 – we simply don't know, we forgot this bit of information.
 We 
\begin_inset Quotes eld
\end_inset

erased
\begin_inset Quotes erd
\end_inset

 it, the origins have been 
\begin_inset Quotes eld
\end_inset

democratized
\begin_inset Quotes erd
\end_inset

: we only have a list 
\begin_inset Formula $\left(x,y,z,s,t\right)$
\end_inset

 but know not whence it came.
\end_layout

\begin_layout Standard
To illustrate the correspondence, list concatenation can also be written
 with an equivalence principle.
 Using the symbol 
\begin_inset Formula $\sim$
\end_inset

 to denote 
\begin_inset Quotes eld
\end_inset

the same as
\begin_inset Quotes erd
\end_inset

, one writes 
\begin_inset Formula 
\[
\left(x,y,z\right)\times\left(s,t\right)\sim\left(x,y\right)\times\left(z,s,t\right)
\]

\end_inset

Using the equivalence 
\begin_inset Formula $\sim$
\end_inset

 to write a quotient space of concatenated products requires the development
 of some additional notion.
 This is partly undertaken in the next section.
\end_layout

\begin_layout Standard
This works for conventional tensors because 
\begin_inset Formula $F,G$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

 are considered to be maps to 
\begin_inset Quotes eld
\end_inset

numbers
\begin_inset Quotes erd
\end_inset

, elements of a field or maybe a ring.
 The multiplication of numbers (members of a field or ring) is also 
\begin_inset Quotes eld
\end_inset

forgetful
\begin_inset Quotes erd
\end_inset

: when we write 
\begin_inset Quotes eld
\end_inset

42
\begin_inset Quotes erd
\end_inset

, we don't know if it was constructed from the product of 6 and 7, or from
 the product of 2 and 21.
 It could have been either of these, or yet more.
 To put it differently, if 
\begin_inset Formula $F\left(a,b,c\right)=6$
\end_inset

 and 
\begin_inset Formula $G\left(d,e\right)=7$
\end_inset

 for fixed constants 
\begin_inset Formula $a,b,c,d,e$
\end_inset

, and we construct the product 
\begin_inset Formula $T\left(a,b,c,d,e\right)=F\left(a,b,c\right)G\left(d,e\right)$
\end_inset

, we no longer know where the 42 came from.
 It might have come from 
\begin_inset Formula $T\left(a,b,c,d,e\right)=H\left(a,b\right)K\left(c,d,e\right)$
\end_inset

 where 
\begin_inset Formula $H\left(a,b\right)=2$
\end_inset

 and 
\begin_inset Formula $K\left(c,d,e\right)=21$
\end_inset

.
 The forgetfulness of list concatenation goes hand-in-hand with the forgetfulnes
s of multiplication in fields and rings.
 Tensors work because the exploit both of these properties.
\end_layout

\begin_layout Subsubsection*
Cartesian products and lambda calculus
\end_layout

\begin_layout Standard
The simply-typed lambda calculus is famously the internal language of Cartesian-
closed categories.
 Let's take a moment to unpack that statement.
 The treatment here is a bit informal; our goal is not to teach category
 theory.
 Consider a class 
\begin_inset Formula $S$
\end_inset

 of symbols.
 We call it a class because it could be a finite set, or an infinite set;
 it may be uncountable, or it may be so horridly structured that it cannot
 be expressed as a set.
 For the purposes of comp sci, things are always finite, co calling it a
 class 
\begin_inset Formula $S$
\end_inset

 is merely conventional.
 The elements of 
\begin_inset Formula $S$
\end_inset

 are 
\begin_inset Quotes erd
\end_inset

symbols
\begin_inset Quotes erd
\end_inset

 because, for the purposes here, symbols, and the connotation that they
 
\begin_inset Quotes eld
\end_inset

stand for something
\begin_inset Quotes erd
\end_inset

, is an important property.
\end_layout

\begin_layout Standard
The Cartesian product of elements of 
\begin_inset Formula $S$
\end_inset

 is an ordered list: we already wrote above that 
\begin_inset Formula $a\times b\times c=\left(a,b,c\right)$
\end_inset

 is two different ways of writing the same thing.
 It is convenient to drop the commas, and write 
\begin_inset Formula $\left(a,b,c\right)=\left(a\;b\;c\right)$
\end_inset

 as is standard in Lisp-dialect programming languages.
 Of course, one can likewise construct lists-of-lists, and so on.
 Consider now the collection (class) of all such nested lists-of-lists-of-lists...
 A typical exemplar might look like
\begin_inset Formula 
\[
\left(a\;b\;\left(c\;d\right)\;e\;\left(f\;g\;\left(h\left(j\left(k\left(m\right)\right)\right)\right)\right)\right)
\]

\end_inset

whence the acronym LISP - 
\begin_inset Quotes eld
\end_inset

Lots of InsidiouS Parenthesis
\begin_inset Quotes erd
\end_inset

 comes from.
 Here, the letters were taken to be symbols drawn from the class 
\begin_inset Formula $S$
\end_inset

.
 It is, however, convenient to introduce the notion of variables; for these,
 we write 
\begin_inset Formula $x,y,z,\cdots$
\end_inset

 as always, by convention.
 One can then consider the class of lists with embeded variables in them.
 OK, but things really get interesting when one then considers replacing
 variables by values.
 To do this, the special notation of 
\begin_inset Formula $\lambda$
\end_inset

 is introduced, and one conventionally writes
\begin_inset Formula 
\[
\left(\lambda x.A\right)B\to A\left[x:=B\right]
\]

\end_inset

where both 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are lists (possibly containing variables), and the expression on the left-hand
 side of the arrow is a lambda-binding of the variable 
\begin_inset Formula $x$
\end_inset

 such that any occurrence of the variable 
\begin_inset Formula $x$
\end_inset

 in the list 
\begin_inset Formula $A$
\end_inset

 is to be replaced by the list 
\begin_inset Formula $B$
\end_inset

.
 By convention, that is what the expression on the right hand side of the
 arrow is supposed to mean.
 The arrow itself is meant to denote beta-reduction, the actual act of plugging
 in or substitution of the variable 
\begin_inset Formula $x$
\end_inset

 by the thing 
\begin_inset Formula $B$
\end_inset

 that is to be plugged in.
\end_layout

\begin_layout Standard
Beta reduction takes actual effort and work, it is a computation problem,
 and vastly complex schemes have been developed to perform beta reduction
 rapidly.
 From the comp-sci perspective, it is a highly non-trivial process, no matter
 how obvious it may seem from the short expression above.
\end_layout

\begin_layout Standard
That's it.
 That's the effective definition of simply-typed lambda calculus.
 It is 
\begin_inset Quotes eld
\end_inset

simply typed
\begin_inset Quotes erd
\end_inset

 because all members of the class 
\begin_inset Formula $S$
\end_inset

 are taken to be of the same type.
 There were only four ingredients in the construction:
\end_layout

\begin_layout Itemize
The Cartesian product, which allows the construction of lists (and of lists
 of lists ...).
\end_layout

\begin_layout Itemize
The use of variables as 
\begin_inset Quotes eld
\end_inset

placeholders
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
The use of a special symbol 
\begin_inset Formula $\lambda$
\end_inset

 which is used to call out or bind or name a specific variable.
\end_layout

\begin_layout Itemize
The performance of substitution, named 
\begin_inset Quotes eld
\end_inset

beta-reduction
\begin_inset Quotes erd
\end_inset

, for historical reasons.
\end_layout

\begin_layout Standard
There is, of course, much more that can be said about lambda calculus; this
 hardly scratches the surface.
 But it does show the centrality of the Cartesian product to the construction.
\end_layout

\begin_layout Standard
It also helps highlight just how different list concatenation is from the
 Cartesian product of lists.
 This is a source of tremendous confusion for students of engineering and
 science, and so (as always) it is worth belaboring here.
 By convention, one is introduced to the notion of 
\begin_inset Formula $\mathbb{R}^{n}$
\end_inset

 as the 
\begin_inset Formula $n$
\end_inset

-dimensional Cartesian space.
 It is a coordinate space – the points of Cartesian space are labeled by
 
\begin_inset Formula $n$
\end_inset

 coordinates, taken to be real numbers, 
\emph on
i.e.

\emph default
 taken as elements of 
\begin_inset Formula $\mathbb{R}$
\end_inset

.
 By convention the Cartesian product of such spaces is 
\begin_inset Formula $\mathbb{R}^{m}\times\mathbb{R}^{n}\cong\mathbb{R}^{m+n}$
\end_inset

 where the 
\begin_inset Formula $\cong$
\end_inset

 symbol denotes isomorphism.
 By convention, this works as list concatenation: if one has spatial coordinates
 
\begin_inset Formula $\left(x,y,z\right)$
\end_inset

 in the 3D space 
\begin_inset Formula $\mathbb{R}^{3}$
\end_inset

 and the spatial coordinates 
\begin_inset Formula $\left(s,t\right)\in\mathbb{R}^{2}$
\end_inset

, then, 
\begin_inset Quotes eld
\end_inset

of course
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Formula $\left(x,y,z,s,t\right)\in\mathbb{R}^{5}=\mathbb{R}\times\mathbb{R}\times\mathbb{R}\times\mathbb{R}\times\mathbb{R}$
\end_inset

.
 Notationally, this is a bit unfortunate for our purposes, as it seems to
 be a form of list concatenation.
 Even worse, the right hand side is not a tensor product! Are you confused
 yet? Posed as a riddle, the solution to the riddle is to realize that when
 one writes a tensor 
\begin_inset Formula $T_{ijklm}$
\end_inset

 of five indeces, these indeces are ordinal numbers: integers.
 They are not real-number-valued coordinates of Euclidean space.
 The value of 
\begin_inset Formula $T$
\end_inset

 might be real, but the indexes are not.
 The abundance of notations - parenthesis of various shapes, and commas
 and what-not, can be a bit of a trap.
\end_layout

\begin_layout Subsubsection*
Tensor product, in general
\end_layout

\begin_layout Standard
We now have enough machinery developed to allow a general definition of
 the tensor product.
 Lets return to the form
\begin_inset Formula 
\[
T\left(x,y,z,s,t\right)=F\left(x,y,z\right)G\left(s,t\right)
\]

\end_inset

as a simple product of 
\begin_inset Formula $F\left(x,y,z\right)$
\end_inset

 and 
\begin_inset Formula $G\left(s,t\right)$
\end_inset

.
 This time, we allow 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 to be 
\begin_inset Quotes eld
\end_inset

anything with a forgetful product
\begin_inset Quotes erd
\end_inset

 – not numbers, but anything which can be 
\begin_inset Quotes eld
\end_inset

multiplied
\begin_inset Quotes erd
\end_inset

 together, in some forgetful way, so that the origin of the factors is no
 longer identifiable.
 We had been previously vague as to whether the 
\begin_inset Formula $x,y,z,s,t$
\end_inset

 were variables or constants; we may proceed with this vagueness, except
 that now we generalize them not to be ordinals, but to be members of some
 class 
\begin_inset Formula $S$
\end_inset

.
 The ordinal property of the indexes is not relevant, here.
\end_layout

\begin_layout Standard
Replacing numbers by things that can be forgetfully multiplied discards
 the addition of tensors.
 This, however, is an important property that we want to maintain.
 This can be done by going 
\begin_inset Quotes eld
\end_inset

meta-mathematical
\begin_inset Quotes erd
\end_inset

 in the conventional sense, and using the disjunctive-or to combine generalized
 tensors.
 The disjunctive-or is a 
\begin_inset Quotes eld
\end_inset

menu choice
\begin_inset Quotes erd
\end_inset

: it says 
\begin_inset Quotes eld
\end_inset

pick this or pick that, pick at least one, but don't pick both
\begin_inset Quotes erd
\end_inset

.
 If we have generalized tensors 
\begin_inset Formula $T$
\end_inset

 and 
\begin_inset Formula $U$
\end_inset

, we can no longer write 
\begin_inset Formula $T+U$
\end_inset

 because there is no addition, but we can still combine them with disjunctive
 choice: I can present you with 
\begin_inset Formula $T\vee U$
\end_inset

 and demand that you pick either 
\begin_inset Formula $T$
\end_inset

 or 
\begin_inset Formula $U$
\end_inset

.
 By convention, the disjunctive-or is denoted with 
\begin_inset Formula $\vee$
\end_inset

.
\end_layout

\begin_layout Standard
One can still use the 
\begin_inset Formula $\otimes$
\end_inset

 symbol to write the tensor product, or one can omit it entirely, as was
 done above, when we wrote 
\begin_inset Formula $T=FG$
\end_inset

.
 It is often useful keep a tensor product symbol, but, as we've generalized,
 it's conventional to use a slightly different symbol: the ampersand 
\begin_inset Formula $\&$
\end_inset

, and so write 
\begin_inset Formula $T=F\&G$
\end_inset

.
 We now have two symbols: 
\begin_inset Formula $\&$
\end_inset

 and 
\begin_inset Formula $\vee$
\end_inset

 and can ask what the algebra of these symbols is.
 Note very carefully that it is NOT the Boolean algebra.
 We have one distributive property, but not the other.
 So, 
\begin_inset Formula 
\[
\left(u\vee v\right)\&w=\left(u\&w\right)\vee\left(v\&w\right)
\]

\end_inset

 is the alternate (generalized) form of the conventional distributive property
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left(u+v\right)\otimes w=u\otimes w+v\otimes w
\]

\end_inset

However, the other one, that would have made things Boolean, does not hold:
\begin_inset Formula 
\[
\left(u\&v\right)\vee w\ne\left(u\&w\right)\vee\left(v\&w\right)
\]

\end_inset

This is hardly a surprise, since it is also the case that
\begin_inset Formula 
\[
\left(u\otimes v\right)+w\ne u\otimes w+v\otimes w
\]

\end_inset

which is once again obvious and trivial: tensor products do not form a Boolean
 algebra.
\end_layout

\begin_layout Subsubsection*
Tensor logic
\end_layout

\begin_layout Standard
To round out the algebraic constructions for the tensor product, we can
 do the same thing that was done to obtain (simply-typed) lambda calculus:
\end_layout

\begin_layout Itemize
Define the algebra of 
\begin_inset Formula $\&$
\end_inset

 and 
\begin_inset Formula $\vee$
\end_inset

 over a class of symbols 
\begin_inset Formula $S$
\end_inset


\end_layout

\begin_layout Itemize
Introduce variables as 
\begin_inset Quotes eld
\end_inset

placeholders
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Employ the symbol 
\begin_inset Formula $\lambda$
\end_inset

 to bind or call out a specific variable.
\end_layout

\begin_layout Itemize
Enable beta-reduction.
\end_layout

\begin_layout Standard
This glosses over the need for alpha-conversion and possibly eta-reduction.
 I will call this algebraic system 
\begin_inset Quotes eld
\end_inset

tensor logic
\begin_inset Quotes erd
\end_inset

, as I am not aware of any conventional name for it.
 It is similar to 
\begin_inset Quotes eld
\end_inset

linear logic
\begin_inset Quotes erd
\end_inset

, but is not the same, as it is missing an important ingredient, that of
 conjugation.
\end_layout

\begin_layout Subsection*
Inner product
\end_layout

\begin_layout Standard
Tensors become interesting in engineering and science only after the addition
 of one more ingredient: the inner product.
 The inner product allows tensors to be combined by 
\begin_inset Quotes eld
\end_inset

contracting tensor indeces
\begin_inset Quotes erd
\end_inset

.
 For example, given tensors 
\begin_inset Formula $A_{ijk}$
\end_inset

 and 
\begin_inset Formula $B_{lm}$
\end_inset

 one might consider the contraction
\begin_inset Formula 
\[
C_{ijm}=A_{ijk}B_{km}=\sum_{k}A_{ijk}B_{km}
\]

\end_inset

where the middle expression uses the so-called 
\begin_inset Quotes eld
\end_inset

Einstein convention
\begin_inset Quotes erd
\end_inset

 of summing repeated indexes, whereas on the right the sum is explicit.
 For the moment, the distinction between covariant and contra-variant indeces
 will be ignored; as any discussion of change-of-basis has been ignored,
 it remains appropriate to also ignore issues of contra/covariance.
\end_layout

\begin_layout Standard
The prototypical inner product is that of two vectors, say 
\begin_inset Formula $\vec{a}=\left[a_{1},a_{2},\cdots,a_{n}\right]$
\end_inset

 and 
\begin_inset Formula $\vec{b}=\left[b_{1},b_{2},\cdots,b_{n}\right]$
\end_inset

.
 One writes:
\begin_inset Formula 
\[
i\left(\vec{a},\vec{b}\right)=\vec{a}\cdot\vec{b}=a_{1}b_{1}+a_{2}b_{2}+\cdots+a_{n}b_{n}
\]

\end_inset

For the general case, one needs only to convert notation:
\begin_inset Formula 
\[
i\left(\vec{a},\vec{b}\right)=a_{1}\&b_{1}\vee a_{2}\&b_{2}\vee\cdots\vee a_{n}\&b_{n}
\]

\end_inset

which clearly has the same form despite a vastly different interpretation
 of the symbols.
\end_layout

\begin_layout Subsubsection*
Inner product as connection
\end_layout

\begin_layout Standard
Diagrammatically, the contraction of tensor indeces was earlier depicted
 with a puzzle-shaped diagram, repeated below, with slightly different labeling.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/puzzle-vector.eps
	lyxscale 60
	width 45col%

\end_inset


\end_layout

\begin_layout Standard
The diagram is slightly awkward here; the upper row is meant to depict the
 two vectors, with naked, uncontracted indexes.
 The lower part depicts a scalar, with Einstein-convention repeated indexes
 that are summed over.
 The two different mating puzzle-tab shapes hint at a hidden contra/covariance.
 They are also meant to indicate compatible types.
 That is to say, the type of 
\begin_inset Formula $a_{j}$
\end_inset

 is compatible with the type of 
\begin_inset Formula $b_{k}$
\end_inset

, and so can be multiplied: so, they might both be numbers, or both be something
 else, as long as they can compatibly be multiplied with each-other using
 the product 
\begin_inset Formula $\&$
\end_inset

 between them.
 We return to types shortly.
 The point of the diagram is to re-assert the claim that the inner product
 is just a form of 
\begin_inset Quotes eld
\end_inset

connecting things together
\begin_inset Quotes erd
\end_inset

, this time made notationally explicit.
\end_layout

\begin_layout Subsubsection*
Beta reduction as inner product
\end_layout

\begin_layout Standard
Earlier, also it was claimed that beta-reduction was a form of connecting
 things together.
 How can this be? To recap: when one plugs in 42 for 
\begin_inset Formula $x$
\end_inset

 in 
\begin_inset Formula $f\left(x\right)$
\end_inset

 to get 
\begin_inset Formula $f\left(42\right)$
\end_inset

, one is 
\begin_inset Quotes eld
\end_inset

connecting
\begin_inset Quotes erd
\end_inset

 42 to 
\begin_inset Formula $f\left(x\right)$
\end_inset

.
 This is intuitively obvious, and one can even intuit how the jigsaw-puzzle
 diagram captures this idea.
 Yet it is not (yet) obviously an inner product.
\end_layout

\begin_layout Standard
To demonstrate that it is, one may appeal to the most basic type theory
 to elucidate.
 Here, 42 is an exemplar of the set of 
\begin_inset Quotes eld
\end_inset

integers
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Formula $f\left(x\right)$
\end_inset

 is a 
\begin_inset Quotes eld
\end_inset

function that takes integers
\begin_inset Quotes erd
\end_inset

.
 They can mate together because the types are compatible.
 We can write an integer as
\begin_inset Formula 
\[
1\vee2\vee3\vee\cdots
\]

\end_inset

which is a menu choice - the disjoint union, again.
 It says that 
\begin_inset Quotes eld
\end_inset

you should choose either 1 or choose 2 or choose 3 ...
 but choose at least one, and chose no more than one
\begin_inset Quotes erd
\end_inset

.
 Likewise, the result of plugging in is
\begin_inset Formula 
\[
f\left(1\right)\vee f\left(2\right)\vee f\left(3\right)\vee\cdots
\]

\end_inset

This begins to look like an inner product; the resemblance can be completed
 by writing it as
\begin_inset Formula 
\[
f_{1}\&1\,\vee\,f_{2}\&2\,\vee\,f_{3}\&3\,\vee\cdots
\]

\end_inset

where, of course, 
\begin_inset Formula $f_{1}\&1=f\left(1\right)$
\end_inset

 is how one writes 
\begin_inset Quotes eld
\end_inset

the value of 
\begin_inset Formula $f$
\end_inset

 at one can be obtained by mating together the value one, as a jigsaw-puzzle-tab
, with 
\begin_inset Formula $f_{1}$
\end_inset

 as the corresponding matching jigsaw-puzzle mate
\begin_inset Quotes erd
\end_inset

.
 With the revised notation, its now clear that beta-reduction is a form
 of the inner product.
\end_layout

\begin_layout Standard
To write it this way, there was a slight abuse of the notation 
\begin_inset Formula $\&$
\end_inset

.
 Previously, it was defined as the 
\begin_inset Quotes eld
\end_inset

product of two things of the same type
\begin_inset Quotes erd
\end_inset

; yet here it is used to denote 
\begin_inset Quotes eld
\end_inset

the mating of matching types
\begin_inset Quotes erd
\end_inset

.
 It is convenient to read it both ways; for the moment we sweep this under
 the rug, along with the co/contravariance issue.
 They are not entirely unrelated.
\end_layout

\begin_layout Subsection*
Types and fibers
\end_layout

\begin_layout Standard
Until now
\end_layout

\begin_layout Section*
Applications
\end_layout

\begin_layout Subsubsection*
In linguistics:
\end_layout

\begin_layout Standard
Why, link-grammar, of course.
 its a grammar.
 Its a categorial grammar.
 Type theory.
 Pre-group grammar.
 Stay and Baez rosetta stone.
 And
\end_layout

\begin_layout Subsubsection*
Sheaf Axioms:
\end_layout

\begin_layout Standard
It obeys the sheaf axioms.
\end_layout

\begin_layout Subsubsection*
In AI:
\end_layout

\begin_layout Standard
Inference, theorem proving, planning, constraint satisfaction.
\end_layout

\begin_layout Standard
The planning aspect is that one can arrange a collection of unconnected
 connectors at one end (the starting state) and another at the other end
 (the goal state) and build a bridge between the two.
\end_layout

\begin_layout Standard
frame problem, combinatorial explosion.
\end_layout

\begin_layout Standard
Conclusions:
\end_layout

\begin_layout Standard
There is no such thing as non-fiction; all writing is fundamentally fictional
 at it's root.
 The only way to be non-fictional is to be quarks and space-time, the universe
 itself.
\end_layout

\begin_layout Standard
The above is a fancy way of saying that analytic philosophy is blarney,
 and that the quest for symbolic AI is doomed.
 One cannot unambiguously assign speech-act labels to text, or symbols to
 meaning.
 The problem lies beyond mere 
\begin_inset Quotes eld
\end_inset

fuzziness
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

probability
\begin_inset Quotes erd
\end_inset

, Bayesian or otherwise.
\end_layout

\begin_layout Standard
Yet, despite these problems, there is a way forward in relationships, without
 insisting on cause and effect, premise and inference, (Bayesian) prior
 and deduction.
 Directionality can be useful, but it is an infelicity, a trap with yawning
 abysses of foundational problems, not the least of which is the concept
 of 
\begin_inset Quotes eld
\end_inset

well-foundedness
\begin_inset Quotes erd
\end_inset

 itself.
 Restricted compositionality is more powerful and more general.
\end_layout

\begin_layout Section*
AtomSpace
\end_layout

\begin_layout Standard
The AtomSpace is a graph database intended to provide generic support for
 knowledge representation, logical inference, and symbolic AI reasoning.
 It provides a large variety of operators for constructing terms and defining
 relations, as well as a fairly comprehensive type system for assigning
 types to variables and working with signatures of functions and terms.
 In this sense, it incorporates many features that are commonly accepted
 in quotidian computer science.
 There is some question about how the existing AtomSpace implementation
 should inter-operate with the idea of connectors and bonds.
 The goal of this section is to review the existing type system, and how
 it can interface with a connector-and-bond system.
\end_layout

\begin_layout Subsection*
The Atomese Type System
\end_layout

\begin_layout Standard
The existing Atomese type system is an extensible system of types usually
 defined at compile time.
 Although new types can be added at run-time, it is usually useful to have
 a corresponding object-oriented class definition for each type, so that
 the types can 
\begin_inset Quotes eld
\end_inset

do things
\begin_inset Quotes erd
\end_inset

 (be evaluatable, perform numeric operations, perform i/o operations, etc.)
 As a result, the type hierarchy is somewhat limited and fairly rigid.
 Although there are more than 100 different types in use in the current
 system, only a handful of these are relevant to the current discussion.
 A quick sketch of these is given below.
\end_layout

\begin_layout Standard
The core concept underlying Atomese is the 
\noun on
Atom
\noun default
: a globally-unique immutable structure which can be referenced and can
 be used as an anchor for mutable, varying 
\noun on
Value
\noun default
s.
 All 
\noun on
Atom
\noun default
s derive from two basic types: the 
\noun on
Node
\noun default
 and the 
\noun on
Link
\noun default
.
 The 
\noun on
Node
\noun default
 is simply a (UTF-8) string.
 All 
\noun on
Node
\noun default
s having the same string name are in fact the same 
\noun on
Node
\noun default
.
 Very crudely, one can think of 
\noun on
Node
\noun default
s as named vertexes of a graph.
 The 
\noun on
Link
\noun default
 corresponds to a hyper-edge: a 
\noun on
Link
\noun default
 can contain zero, one, two or more 
\noun on
Atom
\noun default
s; it is a possibly-empty list of 
\noun on
Atom
\noun default
s.
 
\noun on
Link
\noun default
s to not have any other properties; in particular, they have no string name.
 Thus, crudely, one may think of a 
\noun on
Link
\noun default
 containing exactly two 
\noun on
Node
\noun default
s as an ordinary graph edge.
 Like 
\noun on
Node
\noun default
s, 
\noun on
Link
\noun default
s are globally unique: there can only ever be one 
\noun on
Link
\noun default
 containing a given list of 
\noun on
Atom
\noun default
s.
 It is very convenient to think of a 
\noun on
Link
\noun default
 as a vertex internal to a tree; the 
\noun on
Node
\noun default
s are the leafs of the tree.
 The trees are necessarily acyclic, and finite; it is not possible to construct
 a 
\noun on
Link
\noun default
 that contains itself.
\end_layout

\begin_layout Standard
The AtomSpace is a container for 
\noun on
Atom
\noun default
s.
 As each 
\noun on
Atom
\noun default
 is effectively a tree, one can think of it as a forest-of-trees.
 However, since each 
\noun on
Atom
\noun default
 is globally unique (within an AtomSpace), a more accurate conceptual visualizat
ion is that of a rhizome or woolen felt, as different trees typically share
 the same branches.
 In the following, s-expressions will be used to write down trees.
\end_layout

\begin_layout Subsubsection*
VariableNode
\end_layout

\begin_layout Standard
Declares the name of a variable.
 For example, 
\family typewriter
(VariableNode 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

)
\family default
.
\end_layout

\begin_layout Subsubsection*
TypedVariableLink
\end_layout

\begin_layout Standard
Associates a type declaration with a variable.
 For example, 
\family typewriter
(TypedVariable (Variable 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

) (Type 
\begin_inset Quotes eld
\end_inset

ConceptNode
\begin_inset Quotes erd
\end_inset

))
\family default
.
 This states that the the variable is necessarily of type 
\begin_inset Quotes eld
\end_inset


\noun on
Concept
\noun default

\begin_inset Quotes erd
\end_inset

, with 
\noun on
ConceptNode
\noun default
 being one of the many predefined types in the system.
 The 
\noun on
TypeNode
\noun default
 is just a 
\noun on
Node
\noun default
 whose string name must be the string representation of a simple type.
\end_layout

\begin_layout Subsubsection*
SignatureLink
\end_layout

\begin_layout Standard
A mechanism to declare or construct a compound or complex type.
 For example, 
\family typewriter
(Signature (EvaluationLink (PredicateNode 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

) (ListLink (Type 
\begin_inset Quotes eld
\end_inset

Concept
\begin_inset Quotes erd
\end_inset

) (Type 
\begin_inset Quotes eld
\end_inset

Concept
\begin_inset Quotes erd
\end_inset

))))
\family default
 constructs a type consisting of two 
\noun on
Concept
\noun default
s, and given a fixed label of 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

.
 The specific meaning of 
\noun on
EvaluationLink
\noun default
, 
\noun on
ListLink
\noun default
 and 
\noun on
PredicateNode
\noun default
 are of no particular concern here, they're merely examples of some of the
 predefined types in the Atomese system.
\end_layout

\begin_layout Subsubsection*
Other type constructors
\end_layout

\begin_layout Standard
The system contains several other type constructors, including those for
 type union and type intersection.
\end_layout

\begin_layout Section*
Bibliography
\end_layout

\begin_layout Itemize
Marius Buliga (2003).
 
\begin_inset Quotes eld
\end_inset

Artificial chemistry experiments with chemlambda, lambda calculus, interaction
 combinators.
\begin_inset Quotes erd
\end_inset

 https://arxiv.org/abs/2003.14332
\end_layout

\begin_layout Itemize
Erik Meijer and Gavin Bierman (2011).
 
\begin_inset Quotes eld
\end_inset

A co-Relational Model of Data for Large Shared Data Banks.
\begin_inset Quotes erd
\end_inset

 
\emph on
ACM Databases
\emph default
 Volume 9, issue 3.
\end_layout

\begin_layout Itemize
Van Inwagen, P.
 (2002).
 “The Number of Things.” 
\emph on
Philosophical Issues
\emph default
 12 pp.176–196.
\end_layout

\end_body
\end_document
