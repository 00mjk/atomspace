#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "times" "default"
\font_sans "helvet" "default"
\font_typewriter "courier" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Learning, Searching, Querying, Parsing
\end_layout

\begin_layout Author
Linas Vepstas
\end_layout

\begin_layout Date
31 August 2020
\end_layout

\begin_layout Abstract
Shifting from a viewpoint of 
\begin_inset Quotes eld
\end_inset

variables and values
\begin_inset Quotes erd
\end_inset

 to a viewpoint of 
\begin_inset Quotes eld
\end_inset

connectors that connect
\begin_inset Quotes erd
\end_inset

 unites the theories of search (query and query languages) with the theories
 of parsing (deducing structure from input lacking structure).
 This provides a new and yet very natural theory of learning.
 Most notably, it solves the chicken-and-egg problem of 
\begin_inset Quotes eld
\end_inset

how do you search for somethig when you don't know what you are searching
 for?
\begin_inset Quotes erd
\end_inset

.
 It then recasts learning as a process that begins with a search for unknown
 things, then categorizing the new discoveries based on relationships.
\end_layout

\begin_layout Section*
Introduction
\end_layout

\begin_layout Standard
The concepts of querying, parsing and learning are normally considered to
 be quite distinct.
 This text unifies these concepts by replacing the concept of 
\begin_inset Quotes eld
\end_inset

plugging in a value into a variable
\begin_inset Quotes erd
\end_inset

 by the concept of 
\begin_inset Quotes eld
\end_inset

connecting two things together
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

query
\begin_inset Quotes erd
\end_inset

 here refers to the conventional idea of database queries; the query of
 SQL or GraphQL.
 Such queries are generally formulated as a generalized 
\begin_inset Quotes eld
\end_inset

pattern matching
\begin_inset Quotes erd
\end_inset

: one specifies a fixed part of a pattern, and a variable part, to be filled
 out.
 A textbook example of an SQL query might be 
\begin_inset Quotes eld
\end_inset

find all employees in sales
\begin_inset Quotes erd
\end_inset

, which is understood to be the directive to look at the 
\begin_inset Quotes eld
\end_inset

employees
\begin_inset Quotes erd
\end_inset

 table, and which contains two columns: the name of the employee, and the
 department they work in.
 The fixed part of the query is that the department must be 
\begin_inset Quotes eld
\end_inset

sales
\begin_inset Quotes erd
\end_inset

; the variable is the 
\begin_inset Quotes eld
\end_inset

employees
\begin_inset Quotes erd
\end_inset

.
 The actual syntax for such search, in SQL is 
\begin_inset Quotes eld
\end_inset


\family typewriter
\shape slanted
\emph on
SELECT name FROM employees WHERE department='sales';
\family default
\shape default
\emph default

\begin_inset Quotes erd
\end_inset

.
 Graph query languages, and the subgraph isomorphism problem are similar
 in nature: one specifies a collection of vertexes and edges (which may
 be labelled or unlaballed, directed or undirected), taken to be 
\begin_inset Quotes eld
\end_inset

fixed
\begin_inset Quotes erd
\end_inset

, and another region, variable, and then asks for all matching graphs that
 contain the fixed part.
 The variables are always named (unless there is only one, and then it can
 be anonymous): variables are X,Y,Z, ...
 and are generally typed (in SQL, the employee name is a string, the salary
 is a number.)
\end_layout

\begin_layout Standard
Consider then, the following query/pattern match.
 The database contains "
\emph on
Mike threw a ball.
 Joe threw a ball.
 Ben ate a pizza.
 The engine threw a crankshaft.
\emph default
", however that may be represented; for brevity, we skip the precise representat
ion.
 Consider the query pattern 
\begin_inset Quotes eld
\end_inset


\emph on
____ threw a ball.
\emph default

\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\emph on
X threw a ball.
\emph default

\begin_inset Quotes erd
\end_inset

 which 
\emph on
X
\emph default
 a named variable.
 This is a basic fill-in-the-blanks search.
 The variable 
\emph on
X
\emph default
 may be typed: "
\emph on
X must be a noun
\emph default
" or perhaps "
\emph on
X must be a given name
\emph default
".
 Typing helps narrow the search, and make if more precise.
 In practical applications, typing often provides a huge performance boost,
 and avoids paradoxes and ambiguity.
 Anyway: this search is straight-forward, and yeilds the expected results.
\end_layout

\begin_layout Standard
Consider now the case of relational data.
 Suppose the database indicates relationships; for example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

     +------>WV------>+-----Os----+
\end_layout

\begin_layout Plain Layout

     +-->Wd---+--Ss---+     +-Ds--+
\end_layout

\begin_layout Plain Layout

     |        |       |     |     |
\end_layout

\begin_layout Plain Layout

 LEFT-WALL  Mike    threw   a   ball
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is a gragh, indicating syntactic relationships: 
\family typewriter
S
\family default
 is a subject-verb relationship, 
\family typewriter
O
\family default
 is an object-verb relationship, 
\family typewriter
D
\family default
 is a determiner, and so on.
 Consider the query 
\begin_inset Quotes eld
\end_inset


\emph on
connector-S threw a ball
\emph default
.
\begin_inset Quotes erd
\end_inset

 This is a relational query; we are asking for all things that have a relation
 
\family typewriter
S
\family default
 to the fixed part of the query.
 For the same dataset, this query returns the same results.
 Yet the flavor of the query is different.
\end_layout

\begin_layout Standard
Perhaps this second form seems arcane, or the doorway to some sneaky cheat.
 In this case, a simpler way of posing the example would be the query 
\begin_inset Quotes eld
\end_inset


\emph on
(things that have the property of being to the left of) threw a ball.
\emph default

\begin_inset Quotes erd
\end_inset

 The 
\begin_inset Quotes eld
\end_inset


\emph on
things that have the property of being to the left of
\emph default

\begin_inset Quotes erd
\end_inset

 is a relationship.
 Let's call this relationship 
\begin_inset Quotes eld
\end_inset


\family typewriter
S
\family default

\begin_inset Quotes erd
\end_inset

 for short.
\end_layout

\begin_layout Standard
Relational queries are fundamentally different than variable queries.
 For the first query form, "
\emph on
noun
\emph default
" and "
\emph on
given name
\emph default
" have to be known, tagged properties of "
\emph on
John
\emph default
", "
\emph on
Mike
\emph default
".
 Somehow, through some magic pre-processing, these nodes had been tagged
 with these properties, so that they are known before the search is started.
 Failure-to-tag means failure-of-search.
 If the database contains 
\begin_inset Quotes eld
\end_inset


\emph on
Flooglebarf threw a ball.
\emph default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\emph on
flooglebarf
\emph default

\begin_inset Quotes erd
\end_inset

 had not been previously tagged as a noun, the search will fail to find
 this candidate answer.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Caution, do not be confused.
 The query was 
\begin_inset Quotes eld
\end_inset


\emph on
X throw a ball where X is of type noun
\emph default

\begin_inset Quotes erd
\end_inset

.
 Of course, one may attempt untyped-variable searches.
 The discussion here is trying to pry apart the subtle distinctions between
 variables and relationships, and the role of typing in each.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the second search form, the properties of "
\emph on
Mike
\emph default
" (or 
\begin_inset Quotes eld
\end_inset


\emph on
flooglebarf
\emph default

\begin_inset Quotes erd
\end_inset

) are unknown, not yet worked out or tagged.
 We just know that "
\emph on
Mike
\emph default
" participates in a network of relationships, in this case an 
\family typewriter
S
\family default
-type relationship.
 Oh wait, but 
\family typewriter
S
\family default
 is a type! ...
 but that does not mean that "
\emph on
Mike
\emph default

\begin_inset Quotes erd
\end_inset

 is of type 
\family typewriter
S
\family default
, only that "
\emph on
Mike
\emph default

\begin_inset Quotes erd
\end_inset

 participates in a relationship of type 
\family typewriter
S
\family default
.
\end_layout

\begin_layout Standard
This allows one to find things, without knowing what they are in advance.
 One may have observed a network of relationships, but not the properties
 of the thing-itself.
 Perhaps later, you are able to deduce that "
\emph on
Mike
\emph default
" is a noun, perhaps that it is a given name, and maybe even that "
\emph on
Mike
\emph default
" is a specific individual at some given point in space and time.
 There was no need to know this, before starting the search for ball-throwers.
 
\end_layout

\begin_layout Standard
The first form has a chicken-and-egg problem: how can I know "
\emph on
Mike
\emph default
" is a person? Because I saw Mike do the kind of things that people do.
 But how can I see Mike? If I can only see things of type "people", and
 if I don't already know that 
\begin_inset Quotes eld
\end_inset


\emph on
Mike
\emph default

\begin_inset Quotes erd
\end_inset

 (or 
\begin_inset Quotes eld
\end_inset


\emph on
Flooglebarf
\emph default

\begin_inset Quotes erd
\end_inset

) is of type "
\emph on
people
\emph default
", then search result fails; or rather, it fails to return these as obvious
 candidates.
\end_layout

\begin_layout Standard
The second form does not have the chicken-and-egg problem.
 One may observe things participating in some relationship; after a while
 one may deduce that those things are 
\begin_inset Quotes eld
\end_inset


\emph on
people
\emph default

\begin_inset Quotes erd
\end_inset

 (have type 
\begin_inset Quotes eld
\end_inset


\emph on
people
\emph default

\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Subsection*
Learning
\end_layout

\begin_layout Standard
The distinctions above may seem to be subtle, if not outright gratuitous
 or even confused and delusional.
 One may be tempted to make the claim that 
\begin_inset Quotes eld
\end_inset


\emph on
Mike
\emph default

\begin_inset Quotes erd
\end_inset

 is of type 
\family typewriter
T
\family default
 that is able to participate in relationship 
\family typewriter
S
\family default
.
 This would then be followed by a claim that the two forms are isomprphic
 and can transmuted into one another.
 In some abstract sense, this is correct.
 In practice, the type of 
\family typewriter
T
\family default
 is much weaker than that of 
\begin_inset Quotes eld
\end_inset


\emph on
noun
\emph default

\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\emph on
given name
\emph default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Observing a relationship predates assignment of a type.
 Say, you are on a hike, and someone asks "
\emph on
See that thing, next to the tree? What is that?
\emph default
" The typing applied here is quite weak: the type
\family typewriter
 T
\family default
 is the type "things you can see with your eyes".
 Of course, it's that, but that is almost a universal type; it is much weaker
 than identifying the thing itself.
\end_layout

\begin_layout Standard
Suppose the thing is an antelope -- no one ever asks "
\emph on
See that thing of type antelope next to the tree? What is it?
\emph default
" Such a question presumes knowledge of the answer; the type of "things
 that can be seen" is weaker/broader than the type of all antelopes.
 The lesson here is that the relationship-based query is one of type induction:
 a narrowing of types from broad to fine, a movement from a low-knowlege
 state to a high-knowledge state.
\end_layout

\begin_layout Standard
A more concrete example might be looking at how the Link-Grammar (LG) parser
 deals with unkown words.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
It is the software that produced the diagram above
\end_layout

\end_inset

 Consider the sentence "
\emph on
flooglebarf threw a ball.
\emph default
" The LG parser will parse it just fine.
 Now, "
\emph on
flooglebarf
\emph default
" is not in the dictionary of known words, so some guesses are made.
 The obvious first guess is that "flooglebarf" is a word 
\emph on
i.e
\emph default
.
 it has type 
\family typewriter
T
\family default
=
\begin_inset Quotes erd
\end_inset


\emph on
word
\emph default

\begin_inset Quotes erd
\end_inset

.
 But this is kind of silly, because words are all that there are, for LG.
 Yes, it's a type, but it's the universal type.
\end_layout

\begin_layout Standard
The LG guessing rules include descriptions of generic nouns, generic verbs,
 generic adverbs, 
\emph on
etc.

\emph default
 and each of these are tried in turn.
 Eventually, a valid parse is found.
 Only 
\emph on
after
\emph default
 a valid parse is found, can one conclude that "oh, ah-hah, 
\emph on
flooglebarf
\emph default
 is of type noun, because nouns can participate in relationship 
\family typewriter
S
\family default
".
 Before parsing, the true type of 
\begin_inset Quotes eld
\end_inset


\emph on
flooglebarf
\emph default

\begin_inset Quotes erd
\end_inset

 was unknown.
\end_layout

\begin_layout Standard
To summarize, the claim that "
\emph on
flooglebarf
\emph default

\begin_inset Quotes erd
\end_inset

 (or 
\begin_inset Quotes eld
\end_inset


\emph on
Mike
\emph default

\begin_inset Quotes erd
\end_inset

) has some type 
\family typewriter
T
\family default
 that is able to participate in a relationship of type 
\family typewriter
S
\family default
 is tautological; its vacuously true.
 In practice, one doesn't know what 
\family typewriter
T
\family default
 is, until *after* the relationship was observed! This is the "chicken and
 egg problem" of typed-variable searches.
\end_layout

\begin_layout Subsection*
Parsing
\end_layout

\begin_layout Standard
Per
\end_layout

\end_body
\end_document
