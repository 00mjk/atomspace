#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "times" "default"
\font_sans "helvet" "default"
\font_typewriter "courier" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Graphs, Sheaves, RAM, CPU
\end_layout

\begin_layout Author
Linas Vepstas
\end_layout

\begin_layout Date
2 Sept 2020 draft version 0.2
\end_layout

\begin_layout Abstract
Using connectors-and-sheaves for knowledge representation has distinct implicati
ons for RAM usage and CPU cycles.
 This text sketches and compares memory and CPU usage for three types of
 systems: a naive graph database, the current OpenCog AtomSpace, which is
 an in-RAM metagraph database, and a hypothetical connector-based database.
 The design constraints are such that several different kinds of typical
 knowledge-representation tasks must be efficient and performant; these
 include graph traversal (pattern matching), graph rewriting, and parsing
 (rule application).
\end_layout

\begin_layout Abstract
This is a work in progress ...
\end_layout

\begin_layout Section*
Introduction
\end_layout

\begin_layout Standard
Currently, graph databases are popular, and they have a rather distinct
 performance profile, differing from SQL and noSQL databases.
 The connectors-and-sheaves concepts sketched in this series of texts provide
 a different way of representing graphs, and working with them.
 This representation is not just abstract nonsense, but has actual implications
 for RAM and CPU consumption.
 The current prototype experiments with sheaves are layered on top of the
 OpenCog AtomSpace, which is an in-RAM database for storing generalized
 hypergraphs or 
\begin_inset Quotes eld
\end_inset

metagraphs
\begin_inset Quotes erd
\end_inset

.
 It has it's own distinct representation, with certain implications for
 CPU and RAM utilization.
\end_layout

\begin_layout Standard
The goal of this text is to look at these three systems, and compare how
 they use RAM and CPU resources.
 Describing the AtomSpace is the easiest, because the current implementation
 has a specific form.
 Describing a graph database is a bit harder, as we assume a generic, naive
 design, which actual implementations may or may not follow.
 Describing the connectionist database presents similar trouble: without
 a specific implementation and the experience from using it, statements
 have to be generalized.
\end_layout

\begin_layout Standard
Each of these is described in turn, followed by a discussion of algorithms.
\end_layout

\begin_layout Section*
Graph Representations
\end_layout

\begin_layout Standard
Formally, a graph is
\end_layout

\begin_layout Itemize
A set of vertexes 
\begin_inset Formula $V=\left\{ v_{1},v_{2},\cdots,v_{M}\right\} $
\end_inset


\end_layout

\begin_layout Itemize
A set of edges 
\begin_inset Formula $E=\left\{ e_{1},e_{2},\cdots,e_{N}\right\} $
\end_inset

 where each edge 
\begin_inset Formula $e_{k}$
\end_inset

 is an ordered pair of vertexes drawn from the set 
\begin_inset Formula $V$
\end_inset

.
\end_layout

\begin_layout Standard
Because edges are ordered pairs, it is conventional to denote them with
 arrows, having a head and tail.
 These can be joined together in arbitrary ways.
 Below is a 
\begin_inset Quotes eld
\end_inset

typical
\begin_inset Quotes erd
\end_inset

 directed graph:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/directed-graph.png
	lyxscale 40
	width 30col%

\end_inset


\end_layout

\begin_layout Standard
In practice, one wishes to associate a label to each vertex, and also some
 additional attribute data; likewise for the edges.
 At this time, the JSON format is a very powerful and flexible way of encoding
 attribute data: it can encode variable format structured data consisting
 of strings, numbers, arrays and other kinds of data.
 Thus, for the remainder of this text, it is assumed that attributes are
 encoded in a JSON format.
 There are a variety of ways of encoding JSON; this alone is a substantial
 task, and detailed discussions of this are mostly avoided, except as may
 be relevant.
\end_layout

\begin_layout Standard
In what follows, all data is assumed to live in-RAM; the on-disk representations
 do not concern us.
 One reason for this is that a variety of disk management systems exist,
 and work quite well at abstracting details.
 The earliest such is perhaps the Berkeley DBM, and the Gnu gdbm.
 These have been followed by Google's LevelDB and Facebook's extensions
 RocksDB.
 It is usually not too hard to take an in-RAM database, and layer it on
 top of one of these systems to obtain a disk-backed database.
 Of course, there are numerous ifs-ands-buts, here, these are glossed over.
\end_layout

\begin_layout Standard
The vertex table is straight-forward:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
json-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The goal of having a vertex id (which is necessarily a 
\begin_inset Quotes eld
\end_inset

universally unique id
\begin_inset Quotes erd
\end_inset

 or uid) is that it is required by the edge table.
 The edge table might have the form
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
edge id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
head-vertex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tail-vertex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
json-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
77
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
88
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
99
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
This representation is perhaps too naive.
 To perform a graph traversal, i.e.
 to walk from vertex to vertex, following only connecting edges, one needs
 to know which edges come in, and which edges go out.
 Of course, these can be found in the edge table, but searching the edge
 table is absurd: for an edge table of 
\begin_inset Formula $N$
\end_inset

 edges, such a search takes 
\begin_inset Formula $O\left(N\right)$
\end_inset

 time.
 Thus, we incorporate a special index for edges into the vertex table:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
incoming
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
outgoing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
json-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{77}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{77}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{88,99}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{88}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{88}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Note that the incoming and outgoing columns hold sets: any given vertex
 may appear in more than one edge.
 They are sets, not lists, as the order is not particularly important.
 They are not 
\begin_inset Quotes eld
\end_inset

multisets
\begin_inset Quotes erd
\end_inset

: any given edge appears at most once in the incoming/outgoing sets.
 Suitable representations for sets include hash-tables and trees, each with
 it's own distinct RAM and access-time profile.
\end_layout

\begin_layout Standard
A conventional requirement for graph databases is to locate all nodes and
 vertexes having some particular attribute.
 This opens a Pandora's box of indexing schemes.
 The opening of this box is deferred to a later section, but we can take
 a quick peak: suppose one wants to find all vertexes where the json-data
 has a field called 
\begin_inset Quotes eld
\end_inset

favorite song
\begin_inset Quotes erd
\end_inset

.
 Vertexes representing buildings and automobiles won't have a 
\begin_inset Quotes eld
\end_inset

favorite song
\begin_inset Quotes erd
\end_inset

, vertexes representing people might, but not necessarily.
 Thus, we need to create an index: a set of all vertexes that have this
 tag.
 Every time a vertex is added or removed, this index might have to be updated.
 Thus, adding indexes in this way incurs a CPU overhead.
 If there are 
\begin_inset Formula $J$
\end_inset

 indexes, then there is an 
\begin_inset Formula $O\left(J\right)$
\end_inset

 CPU overhead for vertex insertion/removal.
 There is also RAM consumption: an index containing 
\begin_inset Formula $K$
\end_inset

 items requires at least 
\begin_inset Formula $O\left(K\right)$
\end_inset

 storage, and possibly 
\begin_inset Formula $O\left(K\log K\right)$
\end_inset

.
\end_layout

\begin_layout Section*
Hypergraphs
\end_layout

\begin_layout Standard
A hypergraph is much like a graph, except that the edges, now called 
\begin_inset Quotes eld
\end_inset

hyperedges
\begin_inset Quotes erd
\end_inset

 can contain more than two vertexes.
 That is, the hyperedge, rather than being an ordered pair of vertexes,
 is an ordered list of vertexes.
 The metagraph takes the hypergraph concept one step further: the hyperedge
 may also contain other hyperedges.
 A change of terminology is useful: the basic objects are now called 
\begin_inset Quotes eld
\end_inset

nodes
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

links
\begin_inset Quotes erd
\end_inset

 instead of 
\begin_inset Quotes eld
\end_inset

vertexes
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

edges
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Formally, a hypergraph is:
\end_layout

\begin_layout Itemize
A set of vertexes 
\begin_inset Formula $V=\left\{ v_{1},v_{2},\cdots,v_{M}\right\} $
\end_inset


\end_layout

\begin_layout Itemize
A set of hyperedges 
\begin_inset Formula $E=\left\{ e_{1},e_{2},\cdots,e_{N}\right\} $
\end_inset

 where each hyperedge 
\begin_inset Formula $e_{k}$
\end_inset

 is an ordered list of vertexes drawn from the set 
\begin_inset Formula $V$
\end_inset

.
 This list may be empty, or have one, or two, or more members.
\end_layout

\begin_layout Standard
A metagraph is very nearly the same:
\end_layout

\begin_layout Itemize
A set of nodes 
\begin_inset Formula $V=\left\{ v_{1},v_{2},\cdots,v_{M}\right\} $
\end_inset


\end_layout

\begin_layout Itemize
A set of links 
\begin_inset Formula $E=\left\{ e_{1},e_{2},\cdots,e_{N}\right\} $
\end_inset

 where each hyperedge 
\begin_inset Formula $e_{k}$
\end_inset

 is an ordered list of nodes, or other links.
 It is convenient to call these 
\begin_inset Quotes eld
\end_inset

atoms
\begin_inset Quotes erd
\end_inset

: an atom can be either a node, or a link.
 Links are thus sets of atoms.
\end_layout

\begin_layout Subsection*
Hypergraph representations
\end_layout

\begin_layout Standard
The naive representation for the hypergraph is a straight-forward extension
 of the edge table.
 The example encoded in this table is shown in the figure below.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
edge id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex-list
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
json-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(v_{1}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(v_{1},v_{2}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(v_{3},v_{4}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(v_{3},v_{2},v_{1}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The vertex list may be empty, may hold one, or more vertexes.
 It is necessarily ordered (and thus not a set) and may contain repeated
 entries (a vertex may appear more than once).
 In other respects, it is much the same.
\end_layout

\begin_layout Standard
As before, the ability to traverse the hypergraph is a hard requirement.
 This requires modification to the vertex table.
 Several choices are possible.
 One is to add a new column for each positional location:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
edge-set-0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
edge-set-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
edge-set-2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
json-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{1},e_{2}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{2},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{3},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{2}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
This requires a data-structure that is a list-of-sets, which can be a bit
 overcomplex and challenging to use.
 It is easier to just mash all of these into one set; this is all that is
 needed for hypergraph traversal.
 If the positional location is needed, then it can always be looked up per-edge.
 This is neither technically challenging nor CPU-intensive: the arity of
 hyperedges is typically small, based on real-world mappings to interesting
 datasets.
 Thus, the vertex table can look like
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
incoming-set
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
json-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{1},e_{2},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{2},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{3},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{2}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Note that the vertex table looks a lot like the edge table, the only difference
 being that the vertex-list is an ordered list, while the incoming-set (the
 edge-set) really is a set.
 Effectively, this is because a hypergraph is 
\begin_inset Quotes eld
\end_inset

almost
\begin_inset Quotes erd
\end_inset

 a bipartite graph, having the form below, with the set 
\begin_inset Formula $U$
\end_inset

 on the left being the set of hyperedges.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/hypergraph.eps
	lyxscale 40
	width 40col%

\end_inset


\end_layout

\begin_layout Standard
The boxes denote the fact that the hyperedges are ordered lists.
 The 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $V$
\end_inset

 ellipses are the hyperedge and vertex tables.
\end_layout

\begin_layout Subsubsection*
RAM Utilization
\end_layout

\begin_layout Standard
One might wish to conclude: 
\begin_inset Quotes eld
\end_inset

Oh, but a bipartite graph is just a graph, so a graph database is sufficient
 for all my needs.
\begin_inset Quotes erd
\end_inset

 At some abstract level, this is perhaps true; at the CPU and RAM-consumption
 level, it is not.
 So, in this figure, attributed (the json-data) are attached only to the
 
\begin_inset Formula $v_{k}$
\end_inset

 and 
\begin_inset Formula $e_{k}$
\end_inset

 in the diagram; there is no attribute data attached to the lines in this
 figure.
 What's more, the lines in this figure are not directly recorded in any
 tables; they are implicit only by the structure of the vertex and hyperedge
 tables.
\end_layout

\begin_layout Standard
Counting the memory usage is instructive.
 Lets assume that the size of the vertex-id and the edge-id are the same
 – they are pointers or 64-bit ints – so each id requires 1 unit of RAM.
 Assume that lists are either null-terminated or record a length, so that
 a list of 
\begin_inset Formula $n$
\end_inset

 items requires 
\begin_inset Formula $n+1$
\end_inset

 units of storage.
 Lets encode sets as lists, to make counting easy; let 
\begin_inset Formula $J$
\end_inset

 is the average size of the attribute collection.
 The hyperedges shown in the figure then require 2+3+3+4=12 units of storage,
 plus 5 more for the hyperedge table itself, and 4J of attribute storage.
 The vertexes require 4+3+3+2 units of storage, plus 5 for the vertex-table
 itself, plus 4J more of attributes.
 Summing this, one obtains 34+8J total RAM consumption.
 For the general case, one has
\begin_inset Formula 
\[
N_{V}\left(1+\left\langle J\right\rangle +\left\langle N_{I}\right\rangle \right)+N_{E}\left(1+\left\langle J\right\rangle +\left\langle N_{O}\right\rangle \right)
\]

\end_inset

 where
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N_{V}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of vertexes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N_{E}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of hyperedges
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\langle J\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Average size of attributes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\langle N_{I}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Average size of the incoming set
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\langle N_{O}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Average size of the vertex list
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The average size of the incoming set is equal to the average size of the
 vertex list, so we can approximate 
\begin_inset Formula $\left\langle N_{I}\right\rangle =\left\langle N_{O}\right\rangle $
\end_inset

; the only reason to track these separately is that one may use hash tables
 or trees for sets, whereas lists require arrays.
\end_layout

\begin_layout Standard
The equivalent representation as a graph requires
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\left(N_{V}+N_{E}\right)\left(1+\left\langle J\right\rangle \right)+N_{V}\left\langle N_{I}\right\rangle +N_{E}\left\langle N_{O}\right\rangle  & \quad\mbox{ for the vertex table}\\
N_{V}\left\langle N_{I}\right\rangle \left(3+\left\langle J_{nil}\right\rangle \right) & \quad\mbox{ for the edge table}
\end{align*}

\end_inset

Comparing the two expressions, we see that the vertex table is the same
 size as the complete hypertable.
 The ordinary graph representation also requires the overhead of the edge
 table; here the 
\begin_inset Formula $\left\langle J_{nil}\right\rangle $
\end_inset

 is the cost of storing an empty attribute list, and the factor of 3 comes
 from storing an ordinary edge-id and it's two endpoints.
\end_layout

\begin_layout Subsubsection*
Storing hypergraphs in graphs, and vice-versa
\end_layout

\begin_layout Standard
If the only thing that one is storing are hypergraphs, then having a custom
 hypergraph representation really is smaller than the equivalent bipartite
 graph: it dispenses with the need for an explicit ordinary-edge table.
 Does this mean that there's some magic, here? No, not really.
 Every ordinary graph is a special case of a hypergraph, where the hyper-edge
 always has arity two.
 To store a single edge as an ordinary edge, we need 
\begin_inset Formula $3+\left\langle J\right\rangle $
\end_inset

 units of storage: the edge-label, and the two vertexes in the edge.
 To store a single edge as a hyperedge, we need 
\begin_inset Formula $4+\left\langle J\right\rangle $
\end_inset

 units of storage: the edge-label, the list of vertexes, and the list terminator.
 Thus, storing an ordinary graph as a hypergraph requires 
\begin_inset Formula $N_{E}$
\end_inset

 more units of storage.
 This seems tolerable: for a million-edge graph, and 64-bit pointers, this
 requires 8MBytes of additional storage.
 On modern machines, the extra 8MBytes seems not all that large; there's
 a bit of a penalty in moving from graph storage to hypergraph storage,
 but it's not that much.
 Modern cellphones have 8GBytes of RAM...
\end_layout

\begin_layout Standard
Moving in the opposite direction is much worse: the penalty is 
\begin_inset Formula $N_{V}\left\langle N_{I}\right\rangle \left(3+\left\langle J_{nil}\right\rangle \right)$
\end_inset

 which is surprisingly large.
 Assuming that 
\begin_inset Formula $\left\langle J_{nil}\right\rangle =1$
\end_inset

, then a million-vertex graph requires 
\begin_inset Formula $\left\langle N_{I}\right\rangle $
\end_inset

 times 32MBytes of additional storage.
 For uniformly-distributed graphs, one might have 
\begin_inset Formula $\left\langle N_{I}\right\rangle $
\end_inset

 of 3 to 10; for scale-free graphs of this size, 
\begin_inset Formula $\left\langle N_{I}\right\rangle $
\end_inset

 might be around 14; for square-root-Zipfian graphs (such as Wikipedia page
 views, or biological datasets: genome, proteome, reactome datasets) the
 
\begin_inset Formula $\left\langle N_{I}\right\rangle $
\end_inset

 would be around 200
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The average size of the incoming set is 
\begin_inset Formula 
\[
\left\langle N_{I}\right\rangle =\frac{1}{N_{V}}\int_{1}^{N_{V}}n\left(v\right)dv
\]

\end_inset

where 
\begin_inset Formula $n\left(v\right)$
\end_inset

 is the number of connections to vertex 
\begin_inset Formula $v$
\end_inset

 and 
\begin_inset Formula $N_{V}$
\end_inset

 is the total number of vertexes.
 For a Zipfian distribution, this is
\begin_inset Formula 
\[
\left\langle N_{I}\right\rangle =\frac{1}{N_{V}}\int_{1}^{N_{V}}\frac{N_{V}}{v}dv=\log N_{V}
\]

\end_inset

while for a square-root-Zipfian, one has 
\begin_inset Formula 
\[
\left\langle N_{I}\right\rangle =\frac{1}{N_{V}}\int_{1}^{N_{V}}\frac{AN_{V}}{\sqrt{v}}dv=2A\sqrt{N_{V}}
\]

\end_inset

The scale factor 
\begin_inset Formula $A$
\end_inset

 is data-dependent.
 For wikipedia page views, 
\begin_inset Formula $A\approx20$
\end_inset

, see https://en.wikipedia.org/wiki/Wikipedia:Does_Wikipedia_traffic_obey_Zipf%27s
_law%3F for graphs and discussion.
 For genomics, see https://github.com/linas/biome-distribution/blob/master/paper/
biome-distributions.pdf where 
\begin_inset Formula $A$
\end_inset

 is in the range of 0.1 to 0.3, depending on the dataset.
 These last estimates are a bit glib, as the specifics of the datasets are
 quite subtle.
 Still, one may conclude that these considerations have quite dramatic implicati
ons for graph stores.
\end_layout

\end_inset

, so we are looking at overheads in the gigabyte range.
 There is a huge cost of jamming a hypergraph into an ordinary graph store.
\end_layout

\begin_layout Standard
XXX TODO This is making some rather strong claims about RAM usage, and really
 needs to be quadruple-checked and strengthened.
 It's a bit breezy and casual, as written.
 XXX TODO.
\end_layout

\begin_layout Subsection*
Metagraph representations
\end_layout

\begin_layout Standard
The metagraph differs from the hypergraph in that now a hyperedge (link)
 may contain either another vertex (node) or another link.
 Visually, this is no longer a bipartite graph, but a polytree, such as
 the one shown below.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/metagraph.eps
	lyxscale 60
	width 20col%

\end_inset


\end_layout

\begin_layout Standard
The polytree is more-or-less a directed acyclic graph (DAG), the primary
 difference being that the links are ordered lists, represented as boxes
 in this diagram.
 The node table is effectively the same as the vertex table for the hypergraph,
 before.
 For this graph, it is
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
node id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
incoming-set
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
json-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{1},e_{3}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{1},e_{2}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{2},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The link table now requires both an outgoing-atom list, and an incoming-link
 list.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
link id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
outgoing-list
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
incoming-set
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
json-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(n_{1},n_{2}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{3}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(n_{1},n_{3}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{3}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(e_{1},e_{2},n_{1},e_{2}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(e_{3},n_{3}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Notice how this link-table resembles the vertex-table of an ordinary graph
 store: it has columns for both incoming and outgoing 
\begin_inset Quotes eld
\end_inset

sets
\begin_inset Quotes erd
\end_inset

; the outgoing-set, however, is not a set but an ordered list.
 In terms of designing storage, the naive graph tables, the hypergraph tables,
 and the metagraph tables seem to have much in common.
 This is, however, perhaps a bit deceptive, as performance considrations
 dictate the finer aspects of the design.
\end_layout

\begin_layout Standard
Clearly, the metagraph, having the general shape of a DAG, can be wedged
 into an ordinary graph store.
 Conversely, an ordinary graph is merely a metagraph that never goes more
 than one-level deep, and whose links always have arity-two.
 Eithr format is adequate for representing the other.
 The metagraph, much like the hypergraph, has no need to explicitly declare
 the arrows in the tree; they are not stored, nor do they have attributes.
 The RAM-usage considerations are much like those for the hypergraph.
 More interesting is the structure of indexes, or rather, the alternatives
 one has for index representation.
\end_layout

\begin_layout Section*
Indexing
\end_layout

\begin_layout Standard
The whole point of using a graph database, as opposed to an SQL or noSQL
 database, is that the graph structure encodes something important about
 the problem, something that cannot be easily achieved by doing table joins
 or key-value lookups.
 However, just as with table-based databases, there are certain types of
 queries that are used a lot, and speeding these up through indexing is
 a key ability.
 How might this work, in practice? Let's examine some queries, and see how
 they might work.
\end_layout

\begin_layout Subsubsection*
Single attribute queries
\end_layout

\begin_layout Standard
Suppose one wishes to find all nodes with some specific attribute.
 Naively, this requires walking over all nodes, and then axamining the attached
 attribute structure (presumed to be JSON-like in form) and then extracting
 a named field from the attributes, and examining the value of that field.
 This is a task that SQL databases excel at - for example, 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
SELECT name,salary FROM employees WHERE department='sales';
\family default
\emph default

\begin_inset Quotes erd
\end_inset

.
 A graph database is not needed for this task.
 Nonetheless, this is a plausible task.
 The traditional solution would be 
\begin_inset Quotes eld
\end_inset


\family sans
CREATE INDEX ON employees(department);
\family default

\begin_inset Quotes erd
\end_inset

 which results in the creation of ordered pairs 
\begin_inset Formula $\left(D,\left\{ R\right\} \right)$
\end_inset

 with 
\begin_inset Formula $D$
\end_inset

 the name of the department, and 
\begin_inset Formula $\left\{ R\right\} $
\end_inset

 the set of all records having that value.
 The 
\family typewriter
\emph on
SELECT
\family default
\emph default
 is then straight-forward: it need only return 
\begin_inset Formula $\left\{ R\right\} $
\end_inset

.
 Note that the size of this index is 
\begin_inset Formula $O\left(N\right)$
\end_inset

 where 
\begin_inset Formula $N$
\end_inset

 is the number of employees.
 This is necessarily so: one cannot build an index smaller than the number
 of employees: every employee must be in some department, as, convetionally,
 table-driven databases don't have null entries in rows.
 (Well, in practice, they often do; but now imagine the task of finding
 all records with a null value in some column...) Table-based information also
 has some representational difficulties: imagine the case of an employee
 with dashed-line reporting to multiple departments.
\end_layout

\begin_layout Standard
How might one accomplish indexing like this in a graph database? The simplest,
 most naive answer is to create new, 
\begin_inset Quotes eld
\end_inset

privileged
\begin_inset Quotes erd
\end_inset

 vertexes, one vertex per department.
 They are 
\begin_inset Quotes eld
\end_inset

privileged
\begin_inset Quotes erd
\end_inset

, in that the associated attributes record one and only one value: the name
 of the department.
 Basically, the vertexes are labelled, thus escaping the overhead of crawling
 through a collection of attributes to find one in particular.
 One also created an unlabelled, attribute-free edge, from the department
 name back to the full employee record.
 Finding all employees in 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sales
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 is now trivial: one can trivially find the vertex 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sales
\family default
\emph default

\begin_inset Quotes erd
\end_inset

, and trace all edges to the full record.
 The contents of the graph database, after indexing, is illustrated below.
 Before indexing, the vertexes 
\begin_inset Formula $v_{6},v_{7},v_{8}$
\end_inset

 simply did not exist.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/partial-index.eps
	width 70col%

\end_inset


\end_layout

\begin_layout Standard
The size of this structure is again 
\begin_inset Formula $O\left(N\right)$
\end_inset

 for 
\begin_inset Formula $N$
\end_inset

 employees, assuming every employee is indexed.
 It has some rather unusual properties: not every employee has to be indexed!
 It is possible to create only one vertex, 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sales
\family default
\emph default

\begin_inset Quotes erd
\end_inset

, and hook up edges to only that one.
 Effectively, one has a partial-index, with correspondingly less RAM usage!
 Of course, with some cleverness, an experienced DBA can acheive the same
 effect: 
\begin_inset Quotes eld
\end_inset


\family sans
CREATE INDEX ON employees(department) WHERE department=sales;
\family default

\begin_inset Quotes erd
\end_inset

 and this is not a big deal, so, here, at least, graphs do not offer any
 particular advantage.
 (Under the covers, the SQL databases effectively has more-or-less the same
 format, although thier graph-based nature is 
\emph on
ad hoc
\emph default
, as there are no explicit graph-walking directives in SQL.)
\end_layout

\end_body
\end_document
